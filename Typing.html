<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ExamYatri Typing - Real Exam Simulator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --primary-color: #4CAF50; /* Green for accents */
            --error-color: #F44336;
            --caret-color: #2196F3;
            --disabled-color: #555555;
            --border-color: #333333;
            --font-family: 'Roboto Mono', monospace;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            text-align: center;
        }

        .container {
            width: 90%;
            max-width: 900px;
            margin: 0 auto;
            padding: 1rem 0;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 500;
        }

        .language-switch {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .lang-btn {
            background: transparent;
            color: var(--text-color);
            border: none;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-family: var(--font-family);
            transition: background-color 0.2s;
        }

        .lang-btn.active {
            background-color: var(--primary-color);
        }

        /* Views */
        .view {
            display: none;
            flex-direction: column;
            flex-grow: 1;
        }
        .view.active {
            display: flex;
        }

        /* Setup View */
        #setup-view {
            justify-content: center;
            gap: 1.5rem;
        }

        .setup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .setup-card {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .setup-card label {
            text-align: left;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        .custom-select {
            width: 100%;
            padding: 0.75rem;
            background-color: #111;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: var(--font-family);
            font-size: 1rem;
            cursor: pointer;
        }

        .minus-marking-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
        }
        .minus-marking-controls > div {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .minus-marking-controls input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .minus-marking-controls input[type="number"] {
            width: 60px;
            padding: 0.5rem;
            background-color: #111;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: var(--font-family);
        }

        #start-practice-btn {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            padding: 1rem;
            background-color: var(--primary-color);
            color: #000;
            font-weight: 700;
            border: none;
            border-radius: 6px;
            font-size: 1.2rem;
            font-family: var(--font-family);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        #start-practice-btn:disabled {
            background-color: var(--disabled-color);
            cursor: not-allowed;
        }

        #loading-status {
            min-height: 1.2em;
            margin-bottom: 1rem;
        }
        
        /* Practice View */
        #practice-view {
            gap: 1rem;
        }

        .stats-dashboard {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
        }

        .stat-item {
            display: flex;
            gap: 0.5rem;
            align-items: baseline;
        }
        .stat-item .label {
            font-size: 0.8rem;
            color: #aaa;
        }
        .stat-item .value {
            font-size: 1.2rem;
            font-weight: 700;
        }

        #text-display-wrapper {
            border: 1px solid var(--border-color);
            padding: 1rem;
            border-radius: 6px;
            font-size: 1.5rem;
            line-height: 1.8;
            text-align: left;
            overflow-y: auto;
            scroll-behavior: smooth;
            height: 250px;
            position: relative;
            flex-shrink: 0;
            user-select: none;
            cursor: text;
        }
        
        #text-display {
            color: #888;
            position: relative;
            overflow-wrap: break-word; /* Prevents text from overflowing horizontally */
        }
        #text-display.hindi {
            font-family: 'Noto Sans Devanagari', serif;
        }

        .char {
            display: inline;
        }
        .char.correct { color: var(--primary-color); }
        .char.incorrect { color: var(--error-color); text-decoration: underline; }
        
        .caret {
            position: absolute;
            width: 2px;
            background-color: var(--caret-color);
            animation: blink 1s infinite;
            transition: left 0.1s linear, top 0.1s linear;
            border-radius: 1px;
            height: calc(1.5rem * 1.2);
            margin-top: calc(1.5rem * 0.2);
        }
        @keyframes blink { 50% { opacity: 0; } }

        #hidden-input {
            position: fixed;
            left: 0;
            top: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            margin: -1px;
            padding: 0;
            border: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
        }

        #free-hand-area {
            width: 100%;
            height: 100%;
            background: #111;
            color: var(--text-color);
            border: none;
            font-size: 1.2rem;
            font-family: inherit;
            resize: none;
            padding: 1rem;
        }

        #submit-test-btn {
            padding: 0.75rem 2rem;
            background-color: var(--error-color);
            color: var(--text-color);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 0 auto;
        }
        
        /* New Results Modal */
        #results-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
            padding: 1rem;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #results-modal.active {
            display: flex;
        }

        .results-content {
            background-color: #2a2a2e;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            width: 100%;
            max-width: 850px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            color: #e0e0e0;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }
        .results-content.sad {
            animation: shake 0.5s;
        }

        @keyframes celebrate-fall {
            0% { transform: translateY(-100px) rotateZ(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotateZ(720deg); opacity: 0; }
        }
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 2000;
            animation-name: celebrate-fall;
            animation-timing-function: linear;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
        }
        
        .result-card {
            background-color: #333338;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid #444;
            text-align: left;
        }

        .result-card .title {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 0.5rem;
        }

        .result-card .value {
            font-size: 1.75rem;
            font-weight: 700;
            color: #fff;
        }
         .result-card.qualified .value {
            color: var(--primary-color);
        }
         .result-card.not-qualified .value {
            color: var(--error-color);
        }

        .results-formula-note {
            background-color: #333338;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            text-align: left;
            color: #c0c0c0;
            white-space: pre-wrap;
        }
        .results-formula-note code {
            color: #fff;
            font-weight: bold;
        }
        .results-comparison {
            text-align: left;
        }
        .comparison-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .comparison-passages {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            height: 150px;
        }

        .passage-display {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            font-family: inherit;
            overflow-y: auto;
            text-align: left;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .passage-display span {
            border-radius: 2px;
            padding: 1px 0;
        }

        .correct-word, .passage-display .correct { color: var(--primary-color); }
        .wrong-word, .passage-display .full { color: var(--error-color); background-color: rgba(244, 67, 54, 0.2); text-decoration: line-through; }
        .half-mistake-word, .passage-display .half { color: #FFA500; background-color: rgba(255, 165, 0, 0.2); text-decoration: underline wavy; }
        .omitted-word, .passage-display .omitted { background-color: rgba(158, 158, 158, 0.3); border-radius: 3px; padding: 0 2px; }
        .passage-display .extra { color: var(--error-color); background-color: rgba(244, 67, 54, 0.2); }
        .passage-display .merged, .passage-display .split, .passage-display .space-error { color: #ff9800; background-color: rgba(255, 152, 0, 0.2); }


        .results-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            border-top: 1px solid var(--border-color);
            padding-top: 1.5rem;
            position: sticky;
            bottom: -1.5rem;
            background-color: #2a2a2e;
            margin-left: -1.5rem;
            margin-right: -1.5rem;
            padding-left: 1.5rem;
            padding-right: 1.5rem;
            padding-bottom: 1.5rem;
        }

        .results-actions button {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: #222;
            color: var(--text-color);
            font-family: var(--font-family);
            cursor: pointer;
        }

        /* New styles for analytics */
        #mistakes-analysis ul, #improvement-tips ul {
            list-style: none;
            padding-left: 0;
            margin-top: 0.5rem;
        }
        #mistakes-analysis li, #improvement-tips li {
            margin-bottom: 0.5rem;
        }
        #improvement-tips li {
            padding-left: 1.5rem;
            position: relative;
        }
        #improvement-tips li::before {
            content: '💡';
            position: absolute;
            left: 0;
            top: 2px;
        }

        .mistake-word {
            color: var(--error-color);
            font-weight: bold;
        }
        .suggestion-word {
            color: var(--primary-color);
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .learn-more-link {
            display: block;
            text-align: center;
            margin-top: 1rem;
            color: var(--primary-color);
            cursor: pointer;
            text-decoration: underline;
            font-size: 0.9rem;
        }
        .learn-more-link:hover {
            color: #66bb6a;
        }
        
        @media (min-width: 768px) {
             .charts-container {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .results-grid { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            .result-card .value { font-size: 1.5rem; }
            .comparison-passages { grid-template-columns: 1fr; height: 250px; }
        }

        @media (max-width: 600px) {
            header h1 { font-size: 1.2rem; }
            .setup-grid { grid-template-columns: 1fr; }
            #text-display-wrapper { font-size: 1.2rem; height: 200px; }
            .stat-item .value { font-size: 1rem; }
            .results-header { flex-direction: column; align-items: flex-start; gap: 0.5rem; }
            .results-content { padding: 1rem; }
            .results-actions {
                bottom: -1rem;
                margin-left: -1rem;
                margin-right: -1rem;
                padding-left: 1rem;
                padding-right: 1rem;
                padding-bottom: 1rem;
            }
            .results-grid { 
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }
            .result-card {
                padding: 0.5rem;
            }
            .result-card .title {
                font-size: 0.7rem;
            }
            .result-card .value {
                font-size: 1.1rem;
                word-break: break-all;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="container header-content">
            <h1>ExamYatri Typing</h1>
            <div class="language-switch">
                <button id="lang-english-btn" class="lang-btn active" data-lang="en">English</button>
                <button id="lang-hindi-btn" class="lang-btn" data-lang="hi">हिंदी</button>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- Setup View -->
        <section id="setup-view" class="view active">
            <div class="setup-grid">
                <div class="setup-card">
                    <label for="level-select">Difficulty Level</label>
                    <select id="level-select" class="custom-select"></select>
                </div>
                <div class="setup-card">
                    <label for="method-select">Practice Method</label>
                    <select id="method-select" class="custom-select"></select>
                </div>
                <div class="setup-card">
                    <label for="duration-select">Duration</label>
                    <select id="duration-select" class="custom-select">
                        <option value="1">1 Minute</option>
                        <option value="2">2 Minutes</option>
                        <option value="5" selected>5 Minutes</option>
                        <option value="10">10 Minutes</option>
                        <option value="15">15 Minutes</option>
                        <option value="30">30 Minutes</option>
                    </select>
                </div>
            </div>
            <div id="paste-text-container" style="display: none; width: 100%; margin-bottom: 1rem;">
                <label for="paste-text-area" style="text-align: left; font-size: 0.9rem; color: #ccc; margin-bottom: 0.5rem; display: block;">Paste your text below:</label>
                <textarea id="paste-text-area" style="width: 100%; height: 150px; background: #111; color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; font-family: inherit; font-size: 1rem; padding: 0.75rem; resize: vertical;"></textarea>
            </div>
            <p id="loading-status"></p>
            <button id="start-practice-btn">Start Practice</button>
        </section>

        <!-- Practice View -->
        <section id="practice-view" class="view">
            <div class="stats-dashboard">
                <div class="stat-item"><span class="label">Time:</span><span id="stat-time" class="value">00:00</span></div>
                <div class="stat-item"><span class="label">Gross WPM:</span><span id="stat-gross-wpm" class="value">0</span></div>
                <div class="stat-item"><span class="label">Net WPM:</span><span id="stat-net-wpm" class="value">0</span></div>
                <div class="stat-item"><span class="label">Errors:</span><span id="stat-errors" class="value">0</span></div>
                <div class="stat-item"><span class="label">Accuracy:</span><span id="stat-accuracy" class="value">100%</span></div>
            </div>
            <div id="text-display-wrapper">
                <div id="text-display"></div>
                <div id="caret" class="caret" style="display: none;"></div>
                <textarea id="free-hand-area" style="display: none;" placeholder="Start typing..."></textarea>
            </div>
            <button id="submit-test-btn">Submit Now</button>
        </section>
    </main>

    <!-- New Results Modal -->
    <div id="results-modal">
        <div class="results-content">
            <div class="results-header">
                <div><strong>Passage Title:</strong> <span id="res-passage-title">N/A</span></div>
                <div><strong>Time Duration:</strong> <span id="res-time-duration">00:00</span> min.</div>
                <div><strong>Time Taken:</strong> <span id="res-time-taken">00:00</span> min.</div>
            </div>
            <div class="results-grid">
                <div class="result-card">
                    <div class="title">Total Keystrokes / Words Typed</div>
                    <div class="value"><span id="res-keystrokes">0</span> / <span id="res-words-typed">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Full Mistake (Words)</div>
                    <div class="value"><span id="res-full-mistakes">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Half Mistake (Words)</div>
                    <div class="value"><span id="res-half-mistakes">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Total Wrong Words</div>
                    <div class="value"><span id="res-total-wrong-words">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Accuracy</div>
                    <div class="value"><span id="res-accuracy">0.00</span>%</div>
                </div>
                <div class="result-card">
                    <div class="title">Gross Typing Speed (wpm)</div>
                    <div class="value"><span id="res-gross-speed">0.00</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Net Typing Speed (wpm)</div>
                    <div class="value"><span id="res-net-speed">0.00</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Backspace Count</div>
                    <div class="value"><span id="res-backspace-count">0</span></div>
                </div>
                <div id="res-result-card" class="result-card">
                    <div class="title">Result</div>
                    <div class="value"><span id="res-result-text">N/A</span></div>
                </div>
            </div>
            <div class="results-formula-note">
                <span id="res-formula-note">Calculation of Net Speed = (Total Keystrokes / 5) / Time in Minutes.</span>
            </div>
             <div id="res-keystroke-warning" style="color: var(--error-color); text-align: center; font-size: 0.9rem; margin-top: 1rem;"></div>
            
             <div id="practice-duration-summary" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Practice Duration Summary</div>
                <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 1rem; font-size: 0.9rem; color: #e0e0e0; padding-top: 0.5rem;">
                    <div>Today's Practice: <strong id="res-today-practice-time" style="color: #fff; font-weight: bold;">0m 0s</strong></div>
                    <div>Total on Device: <strong id="res-total-practice-time" style="color: #fff; font-weight: bold;">0h 0m 0s</strong></div>
                </div>
            </div>
            
            <!-- New Analytics Sections -->
            <div id="performance-review-section" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Performance Review</div>
                <div id="performance-feedback" class="value" style="font-size: 1rem; white-space: pre-wrap; color: #e0e0e0; line-height: 1.5;"></div>
            </div>

            <div id="weakness-analysis-section" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Common Mistakes & Weak Areas</div>
                <div id="mistakes-analysis" style="font-size: 0.9rem; color: #e0e0e0;">
                    <div id="english-mistakes-container" style="display: none; margin-bottom: 1rem;">
                        <h4 style="color: #ccc; margin-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.25rem;">English Mistakes</h4>
                        <div id="english-mistakes-list"></div>
                    </div>
                    <div id="hindi-mistakes-container" style="display: none;">
                        <h4 style="color: #ccc; margin-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.25rem;">Hindi Mistakes</h4>
                        <div id="hindi-mistakes-list"></div>
                    </div>
                </div>
            </div>
            
            <div id="improvement-tips-section" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Tips for Improvement</div>
                <div id="improvement-tips" style="font-size: 0.9rem; color: #e0e0e0;"></div>
            </div>

            <div id="progress-graphs-section" style="display: none;">
                <h3 style="text-align: left; margin: 1rem 0 0.5rem; color: #e0e0e0;">Your Progress</h3>
                <div class="charts-container">
                    <canvas id="speed-chart"></canvas>
                    <canvas id="accuracy-chart"></canvas>
                </div>
            </div>

            <div class="results-comparison">
                <div class="comparison-toggle">
                    <label for="comparison-switch">Detailed Comparison</label>
                    <input type="checkbox" id="comparison-switch" checked>
                </div>
                <div class="comparison-passages">
                    <div id="res-original-passage" class="passage-display" aria-readonly="true" role="textbox" aria-label="Original Passage"></div>
                    <div id="res-typed-passage" class="passage-display" aria-readonly="true" role="textbox" aria-label="Typed Passage"></div>
                </div>
            </div>
            <div class="results-actions">
                <button id="retry-test-btn">Retry Same Test</button>
                <button id="new-test-btn">Next Practice Text</button>
                <button id="back-to-home-btn">Back to Home</button>
            </div>
        </div>
    </div>

    <textarea id="hidden-input" autofocus autocapitalize="none" autocorrect="off"></textarea>
    
    <footer style="margin-top: auto; padding: 1rem 0; font-size: 0.9rem; color: #888; border-top: 1px solid var(--border-color);">
        Visitor Count: <span id="visitCount">0</span>
    </footer>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const dom = {
                setupView: document.getElementById('setup-view'),
                practiceView: document.getElementById('practice-view'),
                levelSelect: document.getElementById('level-select'),
                methodSelect: document.getElementById('method-select'),
                durationSelect: document.getElementById('duration-select'),
                loadingStatus: document.getElementById('loading-status'),
                startBtn: document.getElementById('start-practice-btn'),
                pasteTextContainer: document.getElementById('paste-text-container'),
                pasteTextArea: document.getElementById('paste-text-area'),

                stats: {
                    time: document.getElementById('stat-time'),
                    grossWpm: document.getElementById('stat-gross-wpm'),
                    netWpm: document.getElementById('stat-net-wpm'),
                    errors: document.getElementById('stat-errors'),
                    accuracy: document.getElementById('stat-accuracy'),
                },
                textDisplayWrapper: document.getElementById('text-display-wrapper'),
                textDisplay: document.getElementById('text-display'),
                caret: document.getElementById('caret'),
                hiddenInput: document.getElementById('hidden-input'),
                freeHandArea: document.getElementById('free-hand-area'),
                submitBtn: document.getElementById('submit-test-btn'),

                resultsModal: document.getElementById('results-modal'),
                resultsContent: document.querySelector('.results-content'),
                newResults: {
                    passageTitle: document.getElementById('res-passage-title'),
                    timeDuration: document.getElementById('res-time-duration'),
                    timeTaken: document.getElementById('res-time-taken'),
                    keystrokes: document.getElementById('res-keystrokes'),
                    wordsTyped: document.getElementById('res-words-typed'),
                    fullMistakes: document.getElementById('res-full-mistakes'),
                    halfMistakes: document.getElementById('res-half-mistakes'),
                    totalWrongWords: document.getElementById('res-total-wrong-words'),
                    accuracy: document.getElementById('res-accuracy'),
                    grossSpeed: document.getElementById('res-gross-speed'),
                    netSpeed: document.getElementById('res-net-speed'),
                    backspaceCount: document.getElementById('res-backspace-count'),
                    resultCard: document.getElementById('res-result-card'),
                    resultText: document.getElementById('res-result-text'),
                    formulaNote: document.getElementById('res-formula-note'),
                    keystrokeWarning: document.getElementById('res-keystroke-warning'),
                    originalPassage: document.getElementById('res-original-passage'),
                    typedPassage: document.getElementById('res-typed-passage'),
                },
                resultActions: {
                    retry: document.getElementById('retry-test-btn'),
                    newTest: document.getElementById('new-test-btn'),
                    backToHome: document.getElementById('back-to-home-btn'),
                },
                langEnglishBtn: document.getElementById('lang-english-btn'),
                langHindiBtn: document.getElementById('lang-hindi-btn'),
                // New analytics elements
                practiceDurationSummary: document.getElementById('practice-duration-summary'),
                resTodayPracticeTime: document.getElementById('res-today-practice-time'),
                resTotalPracticeTime: document.getElementById('res-total-practice-time'),
                performanceReviewSection: document.getElementById('performance-review-section'),
                performanceFeedback: document.getElementById('performance-feedback'),
                weaknessAnalysisSection: document.getElementById('weakness-analysis-section'),
                mistakesAnalysis: document.getElementById('mistakes-analysis'),
                englishMistakesContainer: document.getElementById('english-mistakes-container'),
                englishMistakesList: document.getElementById('english-mistakes-list'),
                hindiMistakesContainer: document.getElementById('hindi-mistakes-container'),
                hindiMistakesList: document.getElementById('hindi-mistakes-list'),
                improvementTipsSection: document.getElementById('improvement-tips-section'),
                improvementTips: document.getElementById('improvement-tips'),
                progressGraphsSection: document.getElementById('progress-graphs-section'),
                speedChartCanvas: document.getElementById('speed-chart'),
                accuracyChartCanvas: document.getElementById('accuracy-chart'),
            };
            
            const computeTypingMetrics = ({ referenceText = "", typedText = "", timeSeconds = 1 }) => {
                const typedWordsArray = typedText.trim().split(/\s+/).filter(Boolean);
                const referenceSlice = referenceText.trim().split(/\s+/).filter(Boolean).slice(0, typedWordsArray.length).join(" ");
            
                const normalizeText = (t) =>
                    t
                        .replace(/\u200B|\u200C|\u200D/g, "")   // remove zero-width characters
                        .replace(/\s+/g, " ")                   // normalize spaces
                        .replace(/[\u0964\u0965]/g, ".")        // convert Hindi danda to dot
                        .trim();

                const ref = normalizeText(referenceSlice);
                const typed = normalizeText(typedText);
                const refWords = ref.length > 0 ? ref.split(" ") : [];
                const typedWords = typed.length > 0 ? typed.split(" ") : [];

                if (!timeSeconds || timeSeconds <= 0) timeSeconds = 1;

                const levenshtein = (a, b) => {
                    const dp = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));
                    for (let i = 0; i <= a.length; i++) dp[i][0] = i;
                    for (let j = 0; j <= b.length; j++) dp[0][j] = j;
                    for (let i = 1; i <= a.length; i++) {
                        for (let j = 1; j <= b.length; j++) {
                            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                            dp[i][j] = Math.min(
                                dp[i - 1][j] + 1,
                                dp[i][j - 1] + 1,
                                dp[i - 1][j - 1] + cost
                            );
                        }
                    }
                    return dp[a.length][b.length];
                };

                const alignWords = (refWords, typedWords) => {
                    const n = refWords.length, m = typedWords.length;
                    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));
                    for (let i = 0; i <= n; i++) dp[i][0] = i;
                    for (let j = 0; j <= m; j++) dp[0][j] = j;

                    for (let i = 1; i <= n; i++) {
                        for (let j = 1; j <= m; j++) {
                            const cost = refWords[i - 1] === typedWords[j - 1] ? 0 : 1;
                            dp[i][j] = Math.min(
                                dp[i - 1][j] + 1,       // omission
                                dp[i][j - 1] + 1,       // insertion (extra)
                                dp[i - 1][j - 1] + cost // substitution
                            );
                        }
                    }

                    const aligned = [];
                    let i = n, j = m;
                    while (i > 0 || j > 0) {
                        if (i > 0 && j > 0 && refWords[i - 1] === typedWords[j - 1]) {
                            aligned.unshift({ source: refWords[i - 1], typed: typedWords[j - 1], status: "correct" });
                            i--; j--;
                        } else if (i > 0 && j > 0 && dp[i][j] === dp[i - 1][j - 1] + 1) {
                            aligned.unshift({ source: refWords[i - 1], typed: typedWords[j - 1], status: "full" });
                            i--; j--;
                        } else if (i > 0 && dp[i][j] === dp[i - 1][j] + 1) {
                            aligned.unshift({ source: refWords[i - 1], typed: null, status: "omitted" });
                            i--;
                        } else {
                            aligned.unshift({ source: null, typed: typedWords[j - 1], status: "extra" });
                            j--;
                        }
                    }
                    return aligned;
                };

                const perWord = alignWords(refWords, typedWords);

                perWord.forEach((item) => {
                    if (item.status === "full" && item.source && item.typed) {
                        const distance = levenshtein(item.source, item.typed);
                        const len = Math.max(item.source.length, item.typed.length);
                        const ratio = distance / len;
                        if (ratio <= 0.4) item.status = "half";
                    }
                    if (item.typed && item.typed.includes(item.source) && item.typed.length > item.source.length + 2) item.status = "merged";
                    if (item.source && item.source.length > 4 && item.typed && item.typed.includes(" ")) item.status = "split";
                    if (item.source && item.typed && item.source.replace(/\s/g, "") === item.typed.replace(/\s/g, "")) {
                        if (item.source !== item.typed) item.status = "space-error";
                    }
                });

                const fullMistakes = perWord.filter(w => ["full", "merged", "split", "space-error"].includes(w.status)).length;
                const halfMistakes = perWord.filter(w => w.status === "half").length;
                const omittedWords = perWord.filter(w => w.status === "omitted").length;
                const extraWords = perWord.filter(w => w.status === "extra").length;
                const totalMistakes = fullMistakes + halfMistakes + omittedWords + extraWords;
                const totalKeystrokes = typed.length;
                const wordsTypedCount = typedWords.length;
                const minutes = timeSeconds / 60;
                const grossWPM = (totalKeystrokes / 5) / minutes;
                const errorPenalty = (fullMistakes + halfMistakes / 2) / minutes; // Omitted and extra words are NOT penalized
                const netWPM = Math.max(0, grossWPM - errorPenalty);
                const accuracy = grossWPM > 0 ? (netWPM / grossWPM) * 100 : 0;

                return {
                    totalKeystrokes, wordsTypedCount, fullMistakes, halfMistakes,
                    omittedWords, extraWords, totalMistakes,
                    grossWPM: +grossWPM.toFixed(2), netWPM: +netWPM.toFixed(2),
                    accuracyPercent: +accuracy.toFixed(2), wordAnalysis: perWord,
                    referenceSlice // Return the slice for comparison display
                };
            };
            
            const splitTextToChars = (text) => {
                if (typeof Intl.Segmenter === 'function') {
                    try {
                        const segmenter = new Intl.Segmenter(appState.lang, { granularity: 'grapheme' });
                        return Array.from(segmenter.segment(text)).map(g => g.segment);
                    } catch (e) {
                        console.warn("Intl.Segmenter failed, falling back.", e);
                        return Array.from(text);
                    }
                }
                return Array.from(text);
            };
            
            const KEYS = {
                en: { home: "asdfjkl;", top: "qwertyuiop", bottom: "zxcvbnm,.", numbers: "1234567890", symbols: "!@#$%^&*()_+-=[]{}|;':\",./<>?" },
                hi: { home: "ोेि्कसहमतरल", top: "ौैाीपृछठटझफ", bottom: "़ऋदजगबअड़ध", numbers: "१२३४५६७८९०", symbols: "।(),'\"-:", }
            };
             const OFFLINE_FALLBACK = {
                en: [ "The quick brown fox jumps over the lazy dog.", "Technology has changed the way we live and work.", "The internet connects people from all over the world.", "Reading books is a great way to expand your knowledge.", "Success is not final, failure is not fatal: it is the courage to continue that counts.", "The only way to do great work is to love what you do.", "Believe you can and you're halfway there.", "The future belongs to those who believe in the beauty of their dreams.", "Strive not to be a success, but rather to be of value.", "In the middle of every difficulty lies opportunity.", ],
                hi: [ "सूरज की पहली किरण आशा लेकर आती है।", "सच्चा मित्र वही है जो कठिन समय में साथ दे।", "परिश्रम ही सफलता की कुंजी है।", "ज्ञान सबसे बड़ी शक्ति है।", "एक हजार मील की यात्रा एक कदम से शुरू होती है।", "समय किसी का इंतजार नहीं करता।", "स्वस्थ शरीर में ही स्वस्थ मन का वास होता है।", "किताबें हमारी सबसे अच्छी दोस्त होती हैं।", "जीवन एक अनमोल उपहार है, इसे व्यर्थ न करें।", "धैर्य और लगन से हर मुश्किल आसान हो जाती है।", ]
            };
             const STATIC_TEXTS = {
                en: { application: "To,\nThe Hiring Manager,\n[Company Name],\n[Company Address]\n\nSubject: Application for the post of [Job Title]\n\nDear Sir/Madam,\nI am writing to express my keen interest in the [Job Title] position advertised on [Platform]. With my skills and experience, I am confident that I would be a valuable asset to your team. My resume is attached for your review. I look forward to hearing from you soon.\n\nSincerely,\n[Your Name]", legal: "Notwithstanding any other provision of this agreement, the parties agree that neither party shall be liable to the other for any indirect, special, or consequential damages. The validity, interpretation, and performance of this agreement shall be governed by and construed in accordance with the laws of the specified jurisdiction, without regard to its conflict of law principles.", letter: "Dear [Recipient Name],\nI hope this letter finds you well. I am writing to you today to discuss the upcoming project deadline. We need to ensure all deliverables are submitted by the end of the week. Please coordinate with your respective teams to finalize the reports. Your prompt attention to this matter is highly appreciated.\n\nBest regards,\n[Your Name]", punctuation: "Wait, what? He asked, \"Are you sure?\" I'm not sure... let's check the guide (page 5). The options are: red, green, or blue; however, I prefer the first one. It's a 'win-win' situation, isn't it?", capitalization: "The United Nations (UN) headquarters is in New York City. Dr. Smith and his colleague, Professor Jones, attended a conference in Paris, France, last Monday. They discussed the impact of climate change on the Arctic Circle.", symbols: "The formula E=mc^2 is famous. Contact me at user@example.com or call +1 (555) 123-4567. The stock price rose by 15% to $1,234.56. We need to check the file at C:\\Users\\Default\\.", },
                hi: { application: "सेवा में,\nश्रीमान प्रबंधक,\n[कंपनी का नाम],\n[कंपनी का पता]\n\nविषय: [पद का नाम] पद हेतु आवेदन पत्र\n\nमहोदय,\nसविनय निवेदन है कि मुझे [प्लेटफॉर्म] पर विज्ञापित [पद का नाम] पद के लिए आपकी कंपनी में रुचि है। मेरे कौशल और अनुभव के साथ, मुझे विश्वास है कि मैं आपकी टीम के लिए एक मूल्यवान संपत्ति होऊंगा। मेरा बायोडाटा आपके अवलोकन के लिए संलग्न है। मुझे आपसे शीघ्र उत्तर की आशा है।\n\nभवदीय,\n[आपका नाम]", legal: "इस समझौते के किसी अन्य प्रावधान के होते हुए भी, पक्ष इस बात से सहमत हैं कि कोई भी पक्ष दूसरे पक्ष के प्रति किसी भी अप्रत्यक्ष, विशेष, या परिणामी क्षति के लिए उत्तरदायी नहीं होगा। इस समझौते की वैधता, व्याख्या, और प्रदर्शन निर्दिष्ट अधिकार क्षेत्र के कानूनों के अनुसार शासित और समझे जाएंगे, इसके कानून सिद्धांतों के टकराव की परवाह किए बिना।", letter: "प्रिय [प्राप्तकर्ता का नाम],\nआशा है कि आप स्वस्थ होंगे। मैं आज आपसे आगामी परियोजना की समय सीमा पर चर्चा करने के लिए लिख रहा हूं। हमें यह सुनिश्चित करने की आवश्यकता है कि सभी डिलिवरेबल्स सप्ताह के अंत तक जमा कर दिए जाएं। कृपया रिपोर्ट को अंतिम रूप देने के लिए अपनी संबंधित टीमों के साथ समन्वय करें। इस मामले पर आपके त्वरित ध्यान की अत्यधिक सराहना की जाती है।\n\nसाभार,\n[आपका नाम]", punctuation: "रुको, क्या? उसने पूछा, \"क्या तुम निश्चित हो?\" मुझे यकीन नहीं है... चलो गाइड (पेज 5) देखते हैं। विकल्प हैं: लाल, हरा, या नीला; हालाँकि, मुझे पहला वाला पसंद है। यह एक 'जीत-जीत' की स्थिति है, है ना?", capitalization: "संयुक्त राष्ट्र (UN) का मुख्यालय न्यूयॉर्क शहर में है। डॉ. शर्मा और उनके सहयोगी, प्रोफेसर वर्मा, पिछले सोमवार को पेरिस, फ्रांस में एक सम्मेलन में शामिल हुए। उन्होंने आर्कटिक सर्कल पर जलवायु परिवर्तन के प्रभाव पर चर्चा की।", }
            };

            const getRandomFallback = (lang) => OFFLINE_FALLBACK[lang][Math.floor(Math.random() * OFFLINE_FALLBACK[lang].length)];
            const generateRandomText = (chars, wordLength, numWords) => { let text = ''; for (let i = 0; i < numWords; i++) { let word = ''; const currentWordLength = Math.floor(Math.random() * (wordLength - 2)) + 2; for (let j = 0; j < currentWordLength; j++) { word += chars[Math.floor(Math.random() * chars.length)]; } text += word + ' '; } return text.trim(); };
            const getTypingText = async (language = 'en') => {
                 const sources = [
                    async () => { const url = language === 'hi' ? 'https://api.rss2json.com/v1/api.json?rss_url=https://www.jagran.com/education/rssfeed.xml' : 'https://api.rss2json.com/v1/api.json?rss_url=https://www.thehindu.com/education/feeder/default.rss'; const res = await fetch(url, { cache: "no-cache" }); if (!res.ok) throw new Error("RSS Network error"); const data = await res.json(); if (data.status !== 'ok' || !data.items || data.items.length === 0) throw new Error("News source failed"); return data.items[Math.floor(Math.random() * data.items.length)].description.replace(/<[^>]+>/g, '').trim(); },
                    async () => { const url = language === 'hi' ? 'https://hi.wikipedia.org/api/rest_v1/page/random/summary' : 'https://en.wikipedia.org/api/rest_v1/page/random/summary'; const res = await fetch(url); if (!res.ok) throw new Error("Wikipedia Network error"); const data = await res.json(); if (!data.extract) throw new Error("Wikipedia extract failed"); return data.extract; }
                ];
                for (const source of sources) { try { const text = await Promise.race([ source(), new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 4000)) ]); if (text && text.length > 50) return text; } catch (err) { console.warn("A text source failed or timed out, trying next..."); } }
                console.warn("All online sources failed. Using offline fallback."); return getRandomFallback(language);
            };
            const appendMoreText = async () => {
                if (appState.session.isFetchingMoreText || !appState.isPracticeActive) return;
                appState.session.isFetchingMoreText = true; dom.loadingStatus.textContent = 'Generating more text...';
                try {
                    const newText = (await appState.config.textGenerator() || '').normalize("NFC");
                    if (newText && appState.isPracticeActive) {
                        const separator = ' '; appState.config.sourceText += separator + newText; const newChars = splitTextToChars(separator + newText); appState.config.sourceChars.push(...newChars); appState.config.sourceWords = appState.config.sourceText.split(/\s+/).filter(Boolean);
                        const newHtml = newChars.map(char => `<span class="char">${char}</span>`).join(''); dom.textDisplay.insertAdjacentHTML('beforeend', newHtml);
                    }
                } catch (error) { console.error("Failed to generate/fetch more text:", error); } finally { dom.loadingStatus.textContent = ''; appState.session.isFetchingMoreText = false; }
            };
            
            const HINDI_BEGINNER_PRACTICE = { "1. Home Row": "कर हम तरस; महक कसक; कमल महल; सिर किस; केसर कोमल; हमेशा समर;", "2. Top Row": "पठ छठ; पीठ मीठी; पाठ पीठ; कैसा बैठा; फौजी चौकी; मीठा पाठ;", "3. Bottom Row": "जग मग गज; अब जब; धन बढ़; गड़बड़ अजय; अगर डगर; भजन गगन;", "4. Home + Top": "टिकट मिठाई; कठोर कठिन; ठीक ठाक; पहला पहर; महफिल शामिल;", "5. Home + Bottom": "जगह महल; गरम खबर; सहज समझ; बाहर भजन; मदद मकसद;", "6. Top + Bottom": "अटक भटक; पढ़ना चढ़ना; गठन बचपन; अजय अचल;", "7. Word Formation": "किसान किताब; बारिश शामिल; टोकरी कटोरी; पहचान मेहमान;", "9. Random Row Mix": "भारत महान; बचपन की याद; समय का महत्व; सड़क पर गजराज; कलम दवात;" };
            const practiceLevels = {
                "Beginner": { "1. Home Row": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["1. Home Row"]) : generateRandomText(KEYS.en.home, 5, 20), "2. Top Row": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["2. Top Row"]) : generateRandomText(KEYS.en.top, 5, 20), "3. Bottom Row": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["3. Bottom Row"]) : generateRandomText(KEYS.en.bottom, 5, 20), "4. Home + Top": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["4. Home + Top"]) : generateRandomText(KEYS.en.home + KEYS.en.top, 6, 25), "5. Home + Bottom": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["5. Home + Bottom"]) : generateRandomText(KEYS.en.home + KEYS.en.bottom, 6, 25), "6. Top + Bottom": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["6. Top + Bottom"]) : generateRandomText(KEYS.en.top + KEYS.en.bottom, 6, 25), "7. Word Formation": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["7. Word Formation"]) : generateRandomText(KEYS.en.home + KEYS.en.top, 4, 30), "8. Small Sentences": () => Promise.resolve(getRandomFallback(appState.lang)), "9. Random Row Mix": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["9. Random Row Mix"]) : generateRandomText(KEYS.en.home + KEYS.en.top + KEYS.en.bottom, 6, 25), "10. Numeric Practice": () => generateRandomText(KEYS.en.numbers + ' ', 5, 20), },
                "Skill Building": { "1. Random Words": () => getTypingText(appState.lang), "2. Sentence Practice": () => getTypingText(appState.lang), "3. Paragraph Practice": () => getTypingText(appState.lang), "4. Punctuation Practice": () => Promise.resolve(STATIC_TEXTS[appState.lang].punctuation), "5. Capitalization": () => Promise.resolve(STATIC_TEXTS[appState.lang].capitalization), "6. Numeric Row Practice": () => generateRandomText(KEYS.en.numbers + ' 123 456 7890 ', 7, 20), "7. Symbol Typing": () => Promise.resolve(STATIC_TEXTS.en.symbols), "8. Dictation Mode": () => getTypingText(appState.lang), "9. Mixed Practice": () => getTypingText(appState.lang), "10. Repetition Drill": async () => { const s = await getTypingText(appState.lang); return (s + " ").repeat(2).trim(); }, },
                "Advanced": { "1. Editorial Articles": () => getTypingText(appState.lang), "2. Technical Text": () => getTypingText(appState.lang), "3. Application Format": () => Promise.resolve(STATIC_TEXTS[appState.lang].application), "4. Government Notice": () => getTypingText(appState.lang), "5. Table Data Typing": () => Promise.resolve("Name|Age|City|Country\nJohn|30|New York|USA\nAnna|25|Paris|France\nMike|42|Tokyo|Japan"), "6. Speech Text": () => getTypingText(appState.lang), "7. Legal Paragraphs": () => Promise.resolve(STATIC_TEXTS[appState.lang].legal), "8. Complex Sentences": () => getTypingText(appState.lang), "9. News Report Practice": () => getTypingText(appState.lang), "10. Error Correction": () => getTypingText(appState.lang), },
                "Expert": { "1. Long Paragraph": () => getTypingText(appState.lang), "2. Letter Writing": () => Promise.resolve(STATIC_TEXTS[appState.lang].letter), "3. Report Typing": () => getTypingText(appState.lang), "4. Press Release": () => getTypingText(appState.lang), "5. Data Table Typing": () => Promise.resolve("ID,Product,Price,Stock\n101,Laptop,1200,50\n102,Mouse,25,200\n103,Keyboard,75,150\n104,Monitor,300,80"), "6. Essay Typing": () => getTypingText(appState.lang), "7. Mixed Format": () => Promise.resolve(`${STATIC_TEXTS[appState.lang].letter} \n\n ${STATIC_TEXTS[appState.lang].legal}`), "8. Official Document": () => getTypingText(appState.lang), "9. English-Hindi Mix": () => Promise.resolve("This is an English sentence. यह एक हिंदी वाक्य है। We need to type both. हमें दोनों टाइप करने होंगे।"), "10. Multiple Passages": () => getTypingText(appState.lang), },
                "Exam Type": { "1. SSC Exam Mode": () => getTypingText(appState.lang), "2. CPCT Mode": () => getTypingText(appState.lang), "3. RSMSSB Mode": () => getTypingText(appState.lang), "4. UP Police Clerk": () => getTypingText(appState.lang), "5. Bank Clerk Mode": () => getTypingText(appState.lang), "6. Railway Typing": () => getTypingText(appState.lang), "7. High Court Clerk": () => getTypingText(appState.lang), "8. Insurance Typing": () => getTypingText(appState.lang), "9. MP DEO Typing": () => getTypingText(appState.lang), "10. Custom Exam Sim": () => getTypingText(appState.lang), },
                "Free Hand": { "Free Practice": () => Promise.resolve(""), },
                "Uplode Your Text": { "Paste Your Text And Start Practice": () => Promise.resolve(dom.pasteTextArea.value) }
            };
            let appState = {};
            let speedChart, accuracyChart; // Chart instances
            const BACKUP_KEY = 'ExamYatriTypingPermanentBackup';
            const DURATION_KEYS = {
                TODAY: 'ExamYatriTodayPracticeTime',
                TOTAL: 'ExamYatriTotalPracticeTime',
                DATE: 'ExamYatriLastPracticeDate'
            };

            const getStoredResults = () => { try { return JSON.parse(localStorage.getItem(BACKUP_KEY)) || []; } catch (e) { return []; } };
            const saveResults = (results) => { localStorage.setItem(BACKUP_KEY, JSON.stringify(results)); };
            
            const formatDuration = (totalSeconds) => {
                if (totalSeconds < 60) return `${totalSeconds}s`;
                if (totalSeconds < 3600) {
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    return `${minutes}m ${seconds}s`;
                }
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                return `${hours}h ${minutes}m`;
            };

            const updatePracticeTime = (sessionSeconds) => {
                const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
                const lastPracticeDate = localStorage.getItem(DURATION_KEYS.DATE);
                
                let todaySeconds = parseInt(localStorage.getItem(DURATION_KEYS.TODAY) || '0', 10);
                let totalSeconds = parseInt(localStorage.getItem(DURATION_KEYS.TOTAL) || '0', 10);
                
                if (today !== lastPracticeDate) {
                    todaySeconds = 0; // Reset for new day
                }
                
                todaySeconds += sessionSeconds;
                totalSeconds += sessionSeconds;
                
                localStorage.setItem(DURATION_KEYS.TODAY, todaySeconds);
                localStorage.setItem(DURATION_KEYS.TOTAL, totalSeconds);
                localStorage.setItem(DURATION_KEYS.DATE, today);

                return { todaySeconds, totalSeconds };
            };


            const resetState = () => {
                appState = { lang: 'en', timerId: null, isPracticeActive: false, config: { level: '', method: '', duration: 0, sourceText: '', sourceWords: [], sourceChars: [], isDynamicText: false, textGenerator: null }, session: { startTime: 0, timeLeft: 0, typedText: '', charIndex: 0, correctChars: 0, errorCount: 0, keystrokes: 0, backspaceCount: 0, isFetchingMoreText: false }, };
            };
            const populateLevels = () => { dom.levelSelect.innerHTML = Object.keys(practiceLevels).map(level => `<option value="${level}">${level}</option>`).join(''); };
            const populateMethods = () => { const selectedLevel = dom.levelSelect.value; const methods = Object.keys(practiceLevels[selectedLevel]); dom.methodSelect.innerHTML = methods.map(method => `<option value="${method}">${method}</option>`).join(''); handleMethodChange(); };
            const handleMethodChange = () => {
                 const isFreeHand = dom.levelSelect.value === 'Free Hand'; const isPasteText = dom.levelSelect.value === 'Uplode Your Text'; dom.durationSelect.disabled = isFreeHand; dom.pasteTextContainer.style.display = isPasteText ? 'block' : 'none';
            };
            const switchView = (view) => { dom.setupView.classList.toggle('active', view === 'setup'); dom.practiceView.classList.toggle('active', view === 'practice'); };
            const startPractice = async () => {
                if (dom.levelSelect.value === 'Uplode Your Text' && dom.pasteTextArea.value.trim() === '') { alert("Please paste your text before starting."); return; }
                dom.startBtn.disabled = true; dom.loadingStatus.textContent = 'Fetching text...';
                try {
                    const level = dom.levelSelect.value; const method = dom.methodSelect.value; const textGenerator = practiceLevels[level][method];
                    const sourceText = (await textGenerator() || '').normalize("NFC");
                    appState.config = { level: level, method: method, duration: parseInt(dom.durationSelect.value, 10) * 60, isDynamicText: level !== 'Free Hand' && level !== 'Uplode Your Text', textGenerator: textGenerator, sourceText: sourceText, };
                    if (!appState.config.sourceText && appState.config.level !== 'Free Hand') { appState.config.sourceText = getRandomFallback(appState.lang).normalize("NFC"); }
                    if (appState.config.level === 'Free Hand') {
                        dom.textDisplay.style.display = 'none'; dom.caret.style.display = 'none'; dom.freeHandArea.style.display = 'block'; dom.freeHandArea.value = '';
                    } else {
                        dom.textDisplay.style.display = 'block'; dom.freeHandArea.style.display = 'none'; appState.config.sourceWords = appState.config.sourceText.split(/\s+/).filter(Boolean); appState.config.sourceChars = splitTextToChars(appState.config.sourceText); dom.textDisplay.innerHTML = appState.config.sourceChars.map(char => `<span class="char">${char}</span>`).join(''); dom.textDisplay.className = appState.lang === 'hi' ? 'hindi' : '';
                    }
                    resetSession(); switchView('practice'); appState.config.level === 'Free Hand' ? dom.freeHandArea.focus() : dom.hiddenInput.focus();
                } catch (error) { console.error("Failed to start practice:", error); dom.loadingStatus.textContent = 'Error fetching text. Please try again.'; } finally { dom.loadingStatus.textContent = ''; dom.startBtn.disabled = false; }
            };
            const resetSession = () => { if (appState.timerId) clearInterval(appState.timerId); appState.isPracticeActive = false; appState.timerId = null; appState.session = { startTime: 0, timeLeft: appState.config.duration, typedText: '', charIndex: 0, correctChars: 0, errorCount: 0, keystrokes: 0, backspaceCount: 0, isFetchingMoreText: false }; dom.hiddenInput.value = ''; dom.textDisplayWrapper.scrollTop = 0; updateStatsDisplay(); updateTextDisplay(); };
            const handleTyping = () => {
                if (appState.session.timeLeft <= 0 && appState.config.level !== 'Free Hand' && appState.config.duration > 0) return;
                if (!appState.isPracticeActive && appState.config.duration > 0) { appState.isPracticeActive = true; appState.session.startTime = Date.now(); startTimer(); }
                appState.session.typedText = appState.config.level === 'Free Hand' ? dom.freeHandArea.value : dom.hiddenInput.value; updateTextDisplay();
                const remainingChars = appState.config.sourceChars.length - appState.session.charIndex; if (appState.config.isDynamicText && remainingChars < 100) { appendMoreText(); }
                if (appState.config.level !== 'Free Hand' && appState.session.charIndex === appState.config.sourceChars.length && !appState.config.isDynamicText) { endPractice(); }
            };
            const startTimer = () => { if (appState.timerId || appState.config.duration <= 0) return; appState.timerId = setInterval(() => { if (appState.isPracticeActive) { const elapsed = Math.floor((Date.now() - appState.session.startTime) / 1000); appState.session.timeLeft = appState.config.duration - elapsed; updateStatsDisplay(); } if (appState.session.timeLeft <= 0) { endPractice(); } }, 250); };
            const updateTextDisplay = () => {
                if (appState.config.level === 'Free Hand') return;
                const typedChars = splitTextToChars(appState.session.typedText.normalize("NFC"));
                const charElements = dom.textDisplay.querySelectorAll('.char'); 
                appState.session.charIndex = typedChars.length; 
                let correctCount = 0; 
                let errorCount = 0;
                charElements.forEach((charEl, index) => { if (index < appState.session.charIndex) { if (typedChars[index] === appState.config.sourceChars[index]) { charEl.className = 'char correct'; correctCount++; } else { charEl.className = 'char incorrect'; errorCount++; } } else { charEl.className = 'char'; } });
                appState.session.correctChars = correctCount; 
                appState.session.errorCount = errorCount; 
                updateCaretPosition();
            };
             const updateCaretPosition = () => {
                const charElements = dom.textDisplay.querySelectorAll('.char');
                const charIndex = appState.session.charIndex;
                if (charElements.length === 0) { dom.caret.style.display = 'none'; return; }
                dom.caret.style.display = 'block';
                const wrapper = dom.textDisplayWrapper;
                const wrapperRect = wrapper.getBoundingClientRect();
                let targetEl = charIndex >= charElements.length ? charElements[charElements.length - 1] : charElements[charIndex];
                if (!targetEl) { dom.caret.style.display = 'none'; return; }
                const targetRect = targetEl.getBoundingClientRect();
                let left = charIndex >= charElements.length ? targetRect.right - wrapperRect.left : targetRect.left - wrapperRect.left;
                const top = targetRect.top - wrapperRect.top + wrapper.scrollTop;
                dom.caret.style.left = `${left}px`;
                dom.caret.style.top = `${top}px`;
                const caretLineTop = targetEl.offsetTop;
                const caretLineHeight = targetEl.offsetHeight;
                const wrapperHeight = wrapper.clientHeight;
                const currentScrollTop = wrapper.scrollTop;
                const comfortZoneTop = currentScrollTop + wrapperHeight * 0.3;
                const comfortZoneBottom = currentScrollTop + wrapperHeight * 0.7;
                if (caretLineTop < comfortZoneTop) {
                    wrapper.scrollTop = Math.max(0, caretLineTop - wrapperHeight * 0.4);
                } else if (caretLineTop + caretLineHeight > comfortZoneBottom) {
                    wrapper.scrollTop = caretLineTop + caretLineHeight - wrapperHeight * 0.5;
                }
            };
            const updateStatsDisplay = () => {
                const duration = appState.config.duration > 0 ? Math.max(0, appState.session.timeLeft) : (appState.isPracticeActive ? Math.floor((Date.now() - appState.session.startTime) / 1000) : 0);
                const minutes = Math.floor(duration / 60); const seconds = duration % 60; dom.stats.time.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                if (!appState.isPracticeActive && appState.session.startTime === 0) return;
                const elapsedMinutes = (Date.now() - appState.session.startTime) / 60000; if(elapsedMinutes <= 0) return;
                const totalTypedChars = appState.session.typedText.length; const grossWpm = (totalTypedChars / 5) / elapsedMinutes; const errorCount = appState.session.errorCount; const correctChars = totalTypedChars - errorCount;
                const netWpm = elapsedMinutes > 0 ? (correctChars / 5) / elapsedMinutes : 0; const accuracy = totalTypedChars > 0 ? (correctChars / totalTypedChars) * 100 : 100;
                dom.stats.grossWpm.textContent = Math.round(grossWpm); dom.stats.netWpm.textContent = Math.round(Math.max(0, netWpm)); dom.stats.errors.textContent = errorCount; dom.stats.accuracy.textContent = `${Math.round(accuracy)}%`;
            };
            const endPractice = () => { if (!appState.isPracticeActive && appState.session.startTime > 0) return; if (appState.timerId) clearInterval(appState.timerId); appState.isPracticeActive = false; appState.session.timeLeft = 0; updateStatsDisplay(); dom.hiddenInput.blur(); dom.freeHandArea.blur(); showResults(); };
            
            const showResults = () => {
                const timeTakenSec = appState.isPracticeActive ? 0 : (appState.session.startTime > 0 ? Math.round((Date.now() - appState.session.startTime) / 1000) : appState.config.duration);
                const durationMinutes = appState.config.duration / 60;
                
                const metrics = computeTypingMetrics({
                    referenceText: appState.config.sourceText,
                    typedText: appState.session.typedText,
                    timeSeconds: timeTakenSec > 0 ? timeTakenSec : appState.config.duration
                });
                
                const timeTakenMin = (timeTakenSec > 0 ? timeTakenSec : appState.config.duration) / 60;

                const isQualified = metrics.netWPM >= 30 && metrics.accuracyPercent >= 90;

                dom.newResults.passageTitle.textContent = `${appState.config.level}: ${appState.config.method}`;
                dom.newResults.timeDuration.textContent = `${durationMinutes.toFixed(2)}`;
                dom.newResults.timeTaken.textContent = `${timeTakenMin.toFixed(2)}`;
                dom.newResults.keystrokes.textContent = metrics.totalKeystrokes;
                dom.newResults.wordsTyped.textContent = metrics.wordsTypedCount;
                dom.newResults.fullMistakes.textContent = metrics.fullMistakes;
                dom.newResults.halfMistakes.textContent = metrics.halfMistakes;
                dom.newResults.totalWrongWords.textContent = metrics.totalMistakes;
                dom.newResults.accuracy.textContent = metrics.accuracyPercent.toFixed(2);
                dom.newResults.grossSpeed.textContent = metrics.grossWPM.toFixed(2);
                dom.newResults.netSpeed.textContent = metrics.netWPM.toFixed(2);
                dom.newResults.backspaceCount.textContent = appState.session.backspaceCount;
                
                dom.newResults.resultText.textContent = isQualified ? "Qualified" : "Not Qualified";
                dom.newResults.resultCard.className = isQualified ? 'result-card qualified' : 'result-card not-qualified';
                
                const errorPenaltyWords = metrics.fullMistakes + (metrics.halfMistakes / 2);
                const formulaParts = [
                    `<code>Error Penalty = Full (${metrics.fullMistakes}) + Half (${metrics.halfMistakes} ÷ 2) = ${errorPenaltyWords.toFixed(2)} words</code>`,
                    `<code>Gross WPM = (Total Chars Typed ÷ 5) ÷ Time = (${metrics.totalKeystrokes} ÷ 5) ÷ ${timeTakenMin.toFixed(2)} = ${metrics.grossWPM.toFixed(2)}</code>`,
                    `<code>Net WPM = Gross WPM - (Error Penalty ÷ Time) = ${metrics.grossWPM.toFixed(2)} - (${errorPenaltyWords.toFixed(2)} ÷ ${timeTakenMin.toFixed(2)}) = ${metrics.netWPM.toFixed(2)}</code>`,
                    `<code>Note: Omitted and Extra words are not penalized in Net WPM.</code>`
                ];
                dom.newResults.formulaNote.innerHTML = formulaParts.join('\n');

                let originalHTML = '', typedHTML = '';
                metrics.wordAnalysis.forEach(({ source, typed, status }) => {
                    const s = source || '';
                    const t = typed || '';
                    const statusClass = status === 'full' ? 'wrong-word' : status;
                    if (source) originalHTML += `<span class="${statusClass}">${s}</span> `;
                    if (typed) typedHTML += `<span class="${statusClass}">${t}</span> `;
                    else if(status === 'omitted') typedHTML += ' ';
                });
                
                const originalPassageWords = appState.config.sourceText.trim().split(/\s+/).filter(Boolean);
                const referenceSliceWords = metrics.referenceSlice.trim().split(/\s+/).filter(Boolean);
                const untypedWords = originalPassageWords.slice(referenceSliceWords.length);
                const untypedHTML = untypedWords.map(word => `<span class="omitted-word">${word}</span>`).join(' ');

                dom.newResults.originalPassage.innerHTML = originalHTML + ' ' + untypedHTML;
                dom.newResults.typedPassage.innerHTML = typedHTML;

                const currentResult = {
                    timestamp: Date.now(),
                    level: appState.config.level,
                    method: appState.config.method,
                    lang: appState.lang,
                    duration: durationMinutes,
                    grossWPM: metrics.grossWPM,
                    netWPM: metrics.netWPM,
                    accuracy: metrics.accuracyPercent,
                    errors: metrics.totalMistakes,
                    keystrokes: metrics.totalKeystrokes,
                    backspaceCount: appState.session.backspaceCount,
                    qualified: isQualified,
                    wordAnalysis: metrics.wordAnalysis,
                };

                const allResults = getStoredResults();
                allResults.push(currentResult);
                saveResults(allResults);

                const { todaySeconds, totalSeconds } = updatePracticeTime(timeTakenSec);
                dom.practiceDurationSummary.style.display = 'block';
                dom.resTodayPracticeTime.textContent = formatDuration(todaySeconds);
                dom.resTotalPracticeTime.textContent = formatDuration(totalSeconds);

                renderAnalytics(allResults);

                dom.resultsModal.classList.add('active');

                if (metrics.totalMistakes === 0 && metrics.wordsTypedCount > 0) {
                     for (let i = 0; i < 40; i++) {
                        const confetti = document.createElement("div");
                        confetti.className = "confetti";
                        confetti.style.left = Math.random() * 100 + "vw";
                        confetti.style.top = "-20px";
                        confetti.style.background = `hsl(${Math.random()*360},100%,60%)`;
                        confetti.style.animationDuration = Math.random()*2+3 + "s";
                        document.body.appendChild(confetti);
                        setTimeout(() => confetti.remove(), 5000);
                    }
                } else {
                    dom.resultsContent.classList.add("sad");
                    setTimeout(() => dom.resultsContent.classList.remove("sad"), 600);
                }
            };

            const hideResults = () => {
                dom.resultsModal.classList.remove('active');
                if (speedChart) speedChart.destroy();
                if (accuracyChart) accuracyChart.destroy();
                dom.practiceDurationSummary.style.display = 'none';
                dom.performanceReviewSection.style.display = 'none';
                dom.weaknessAnalysisSection.style.display = 'none';
                dom.improvementTipsSection.style.display = 'none';
                dom.progressGraphsSection.style.display = 'none';
            };

            const renderAnalytics = (results) => {
                const currentResult = results[results.length - 1];
                renderPerformanceReview(results);
                renderWeaknessAnalysis(results);
                renderProgressGraphs(results);
                renderImprovementTips(currentResult);
            };

            const renderPerformanceReview = (results) => {
                if (results.length < 2) {
                    dom.performanceReviewSection.style.display = 'none';
                    return;
                }
                dom.performanceReviewSection.style.display = 'block';
                const current = results[results.length - 1];
                const previous = results[results.length - 2];
                
                let feedback = [];
                const wpmDiff = current.netWPM - previous.netWPM;
                const accDiff = current.accuracy - previous.accuracy;
                const errDiff = current.errors - previous.errors;

                if (wpmDiff > 0) feedback.push(`Speed improved by <span style="color:var(--primary-color)">+${wpmDiff.toFixed(2)} WPM</span>.`);
                else if (wpmDiff < 0) feedback.push(`Speed decreased by <span style="color:var(--error-color)">${wpmDiff.toFixed(2)} WPM</span>.`);
                
                if (accDiff > 0) feedback.push(`Accuracy increased by <span style="color:var(--primary-color)">+${accDiff.toFixed(2)}%</span>.`);
                else if (accDiff < 0) feedback.push(`Accuracy decreased by <span style="color:var(--error-color)">${accDiff.toFixed(2)}%</span>.`);

                if (errDiff < 0) feedback.push(`Errors reduced by <span style="color:var(--primary-color)">${-errDiff}</span>.`);
                else if (errDiff > 0) feedback.push(`Errors increased by <span style="color:var(--error-color)">${errDiff}</span>.`);

                if (feedback.length === 0) feedback.push("Your performance is consistent. Keep practicing!");
                else if (wpmDiff > 0 && accDiff > 0) feedback.push("Excellent improvement! Keep up the great work!");
                else if (wpmDiff < 0 || accDiff < 0) feedback.push("Focus on consistency and accuracy in your next session.");
                
                dom.performanceFeedback.innerHTML = feedback.join('\n');
            };

            const renderWeaknessAnalysis = (results) => {
                const generateMistakeList = (filteredResults) => {
                    const mistakeMap = new Map();
                    filteredResults.flatMap(r => r.wordAnalysis || [])
                        .filter(w => w.status !== 'correct' && w.source)
                        .forEach(w => {
                            if (!mistakeMap.has(w.source)) {
                                mistakeMap.set(w.source, { count: 0, typedAs: new Map() });
                            }
                            const entry = mistakeMap.get(w.source);
                            entry.count++;
                            if (w.typed) {
                                entry.typedAs.set(w.typed, (entry.typedAs.get(w.typed) || 0) + 1);
                            }
                        });

                    if (mistakeMap.size === 0) return null;

                    const sortedMistakes = [...mistakeMap.entries()].sort((a, b) => b[1].count - a[1].count).slice(0, 5);
                    
                    let html = '<ul>';
                    sortedMistakes.forEach(([source, data]) => {
                        const commonTyped = [...data.typedAs.entries()].sort((a, b) => b[1] - a[1])[0];
                        html += `<li>Mistyped '<span class="mistake-word">${source}</span>' (${data.count} times)`;
                        if (commonTyped) {
                             html += `, often as '<span class="suggestion-word">${commonTyped[0]}</span>'`;
                        }
                        html += `.</li>`;
                    });
                    html += '</ul>';
                    return html;
                };

                const englishResults = results.filter(r => r.lang === 'en');
                const hindiResults = results.filter(r => r.lang === 'hi');

                const englishMistakesHTML = generateMistakeList(englishResults);
                const hindiMistakesHTML = generateMistakeList(hindiResults);

                let anyMistakesFound = false;

                if (englishMistakesHTML) {
                    dom.englishMistakesContainer.style.display = 'block';
                    dom.englishMistakesList.innerHTML = englishMistakesHTML;
                    anyMistakesFound = true;
                } else {
                    dom.englishMistakesContainer.style.display = 'none';
                }

                if (hindiMistakesHTML) {
                    dom.hindiMistakesContainer.style.display = 'block';
                    dom.hindiMistakesList.innerHTML = hindiMistakesHTML;
                    anyMistakesFound = true;
                } else {
                    dom.hindiMistakesContainer.style.display = 'none';
                }

                dom.weaknessAnalysisSection.style.display = anyMistakesFound ? 'block' : 'none';
            };

            const renderImprovementTips = (currentResult) => {
                const { accuracy, netWPM, grossWPM, backspaceCount, wordAnalysis } = currentResult;
                let tips = [];

                if (accuracy < 90) {
                    tips.push("Your accuracy is low. Try to focus on typing correctly rather than speed. Precision is key!");
                } else if (accuracy < 95) {
                    tips.push("Good accuracy! Slow down just a bit to eliminate those few remaining errors.");
                }

                const wpmDifference = grossWPM - netWPM;
                if (wpmDifference > 10) {
                    tips.push("A high number of errors is reducing your Net Speed. Focus on accuracy to see a big improvement.");
                }

                if (backspaceCount > (currentResult.keystrokes / 20)) { // If backspace is more than 5% of keystrokes
                    tips.push("You're using the backspace key frequently. Try to type more deliberately to build a better rhythm and flow.");
                }
                
                const halfMistakes = (wordAnalysis || []).filter(w => w.status === 'half').length;
                const fullMistakes = (wordAnalysis || []).filter(w => w.status === 'full').length;
                if (halfMistakes > fullMistakes && halfMistakes > 3) {
                     tips.push("You're making many minor typos (half mistakes). Double-check for small errors like an extra or missed letter before moving on.");
                }

                if (tips.length === 0) {
                    tips.push("Great work! Your performance is solid. Keep practicing regularly to maintain and improve your skills.");
                }
                
                dom.improvementTips.innerHTML = '<ul>' + tips.map(tip => `<li>${tip}</li>`).join('') + '</ul>';
                dom.improvementTipsSection.style.display = 'block';
            };


            const renderProgressGraphs = (results) => {
                const recentResults = results.slice(-10);

                if (recentResults.length < 2) {
                    dom.progressGraphsSection.style.display = 'none';
                    return;
                }
                dom.progressGraphsSection.style.display = 'block';

                if (speedChart) speedChart.destroy();
                if (accuracyChart) accuracyChart.destroy();

                const labels = recentResults.map((_, i) => `Test ${results.length - recentResults.length + i + 1}`);
                const speedData = {
                    labels,
                    datasets: [
                        { label: 'Gross WPM', data: recentResults.map(r => r.grossWPM), borderColor: '#2196F3', tension: 0.1, backgroundColor: 'rgba(33, 150, 243, 0.1)', fill: true },
                        { label: 'Net WPM', data: recentResults.map(r => r.netWPM), borderColor: 'var(--primary-color)', tension: 0.1, backgroundColor: 'rgba(76, 175, 80, 0.1)', fill: true }
                    ]
                };
                const accuracyData = {
                    labels,
                    datasets: [
                        { label: 'Accuracy (%)', data: recentResults.map(r => r.accuracy), borderColor: '#FFC107', tension: 0.1, yAxisID: 'y', backgroundColor: 'rgba(255, 193, 7, 0.1)', fill: true },
                        { label: 'Errors', data: recentResults.map(r => r.errors), borderColor: 'var(--error-color)', tension: 0.1, yAxisID: 'y1', backgroundColor: 'rgba(244, 67, 54, 0.1)', fill: true }
                    ]
                };
                
                const chartOptions = {
                    responsive: true, maintainAspectRatio: true,
                    plugins: { legend: { labels: { color: '#ccc' } } },
                    scales: {
                        y: { beginAtZero: true, grid: { color: '#444' }, ticks: { color: '#ccc' } },
                        x: { grid: { color: '#444' }, ticks: { color: '#ccc', maxRotation: 0, autoSkip: true, maxTicksLimit: 10 } }
                    }
                };

                speedChart = new Chart(dom.speedChartCanvas, { type: 'line', data: speedData, options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Typing Speed (WPM)', color: '#fff' } } } });
                accuracyChart = new Chart(dom.accuracyChartCanvas, { type: 'line', data: accuracyData, options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Accuracy & Errors', color: '#fff' } }, scales: { ...chartOptions.scales, y1: { type: 'linear', display: true, position: 'right', beginAtZero: true, grid: { drawOnChartArea: false }, ticks: { color: '#ccc' } } } } });
            };

            const init = () => {
                resetState(); populateLevels(); populateMethods();
                Chart.defaults.color = '#ccc'; Chart.defaults.borderColor = '#444';
                const visitCountEl = document.getElementById("visitCount"); if (visitCountEl) { let count = parseInt(localStorage.getItem("visitorCount") || "0"); count++; localStorage.setItem("visitorCount", String(count)); visitCountEl.textContent = count.toLocaleString(); }
                dom.levelSelect.addEventListener('change', populateMethods);
                dom.methodSelect.addEventListener('change', handleMethodChange);
                [dom.langEnglishBtn, dom.langHindiBtn].forEach(btn => {
                    btn.addEventListener('click', () => {
                        dom.langEnglishBtn.classList.remove('active');
                        dom.langHindiBtn.classList.remove('active');
                        btn.classList.add('active');
                        appState.lang = btn.dataset.lang;
                    });
                });
                dom.startBtn.addEventListener('click', startPractice);
                dom.submitBtn.addEventListener('click', endPractice);
                dom.hiddenInput.addEventListener('input', handleTyping);
                dom.hiddenInput.addEventListener('keydown', (e) => { appState.session.keystrokes++; if (e.key === 'Backspace') { appState.session.backspaceCount++; } if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key)) e.preventDefault(); });
                dom.freeHandArea.addEventListener('input', handleTyping);
                dom.freeHandArea.addEventListener('keydown', (e) => { appState.session.keystrokes++; if (e.key === 'Backspace') { appState.session.backspaceCount++; } });
                dom.textDisplayWrapper.addEventListener('click', () => { appState.config.level === 'Free Hand' ? dom.freeHandArea.focus() : dom.hiddenInput.focus(); });
                
                dom.resultActions.retry.addEventListener('click', () => {
                    hideResults();
                    const oldConfig = { ...appState.config }; resetSession(); appState.config = oldConfig;
                    if(appState.config.level !== 'Free Hand') {
                        dom.textDisplay.innerHTML = appState.config.sourceChars.map(char => `<span class="char">${char}</span>`).join('');
                        dom.textDisplay.className = appState.lang === 'hi' ? 'hindi' : '';
                    }
                     dom.freeHandArea.value = '';
                    switchView('practice');
                    appState.config.level === 'Free Hand' ? dom.freeHandArea.focus() : dom.hiddenInput.focus();
                });
                dom.resultActions.newTest.addEventListener('click', () => {
                    if (appState.config.level === 'Uplode Your Text') dom.pasteTextArea.value = '';
                    hideResults();
                    startPractice();
                });
                dom.resultActions.backToHome.addEventListener('click', () => {
                    if (appState.config.level === 'Uplode Your Text') dom.pasteTextArea.value = '';
                    hideResults();
                    switchView('setup');
                });
            };

            init();
        });
    </script>
</body>
</html>