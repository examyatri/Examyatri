<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ExamYatri Typing - Real Exam Simulator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --primary-color: #4CAF50; /* Green for accents */
            --error-color: #F44336;
            --caret-color: #2196F3;
            --disabled-color: #555555;
            --border-color: #333333;
            --font-family: 'Roboto Mono', monospace;
            --current-word-bg: #D4AF37; /* A more vibrant gold/yellow */
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            text-align: center;
        }

        body.practice-active header,
        body.practice-active footer {
            display: none;
        }

        .container {
            width: 90%;
            max-width: 900px;
            margin: 0 auto;
            padding: 1rem 0;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 500;
        }

        .language-switch {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .lang-btn {
            background: transparent;
            color: var(--text-color);
            border: none;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-family: var(--font-family);
            transition: background-color 0.2s;
        }

        .lang-btn.active {
            background-color: var(--primary-color);
        }

        /* Views */
        .view {
            display: none;
            flex-direction: column;
            flex-grow: 1;
        }
        .view.active {
            display: flex;
        }

        /* Setup View */
        #setup-view {
            justify-content: center;
            gap: 1.5rem;
        }

        .setup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .setup-card {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .setup-card label {
            text-align: left;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        .custom-select {
            width: 100%;
            padding: 0.75rem;
            background-color: #111;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: var(--font-family);
            font-size: 1rem;
            cursor: pointer;
        }

        .minus-marking-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
        }
        .minus-marking-controls > div {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .minus-marking-controls input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .minus-marking-controls input[type="number"] {
            width: 60px;
            padding: 0.5rem;
            background-color: #111;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: var(--font-family);
        }

        #start-practice-btn {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            padding: 1rem;
            background-color: var(--primary-color);
            color: #000;
            font-weight: 700;
            border: none;
            border-radius: 6px;
            font-size: 1.2rem;
            font-family: var(--font-family);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        #start-practice-btn:disabled {
            background-color: var(--disabled-color);
            cursor: not-allowed;
        }

        #loading-status {
            min-height: 1.2em;
            margin-bottom: 1rem;
            color: #aaa;
            font-size: 0.9rem;
        }

        /* === New Mode Toggle Styles === */
        .mode-toggle-container {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .mode-toggle-btn {
            background-color: #222;
            color: var(--text-color);
            border: 2px solid transparent;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-family: var(--font-family);
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        .mode-toggle-btn.active {
            background-color: var(--primary-color);
            color: #000;
            animation: flashing-border 2s infinite;
        }
        @keyframes flashing-border {
            0% { border-color: red; }
            50% { border-color: blue; }
            100% { border-color: red; }
        }
        
        /* Practice View */
        #practice-view {
            gap: 1rem;
        }

        .stats-dashboard {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
        }

        .stat-item {
            display: flex;
            gap: 0.5rem;
            align-items: baseline;
        }
        .stat-item .label {
            font-size: 0.8rem;
            color: #aaa;
        }
        .stat-item .value {
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        #split-display-container {
            display: contents; /* Behaves as if it's not there by default */
        }
        
        #text-display-wrapper {
            border: 1px solid var(--border-color);
            padding: 1rem;
            border-radius: 6px;
            font-size: 1.5rem;
            line-height: 1.8;
            text-align: left;
            overflow-y: auto;
            scroll-behavior: smooth;
            height: 250px;
            position: relative;
            flex-shrink: 0;
            user-select: none;
            cursor: text;
            white-space: normal; /* Allow text to wrap */
        }
        
        #text-display {
            color: #888;
            position: relative;
            overflow-wrap: break-word; /* Prevents text from overflowing horizontally */
        }
        #text-display.hindi {
            font-family: 'Noto Sans Devanagari', serif;
            word-break: keep-all;
            overflow-wrap: normal;
        }

        /* NEW WORD-BASED STYLES */
        .word {
            display: inline-block;
            margin-right: 0.6em; /* Simulates a space */
            line-height: 1.5; /* Ensure consistent line height */
            padding: 2px 0;
        }
        .word.current { 
            background-color: var(--current-word-bg);
            color: #000;
            border-radius: 3px;
        }
        .word.correct { color: var(--primary-color); }
        .word.wrong { 
            color: var(--error-color); 
            text-decoration: line-through; 
            background-color: rgba(244, 67, 54, 0.15);
        }
        .word.half { 
            color: #FFA500; /* Orange */
            text-decoration: underline wavy #FFA500;
            background-color: rgba(255, 165, 0, 0.1);
        }
        .word.omitted {
            color: #888;
            background-color: rgba(136, 136, 136, 0.2);
            border-radius: 3px;
        }
        /* Style for individual characters inside a word */
        .char { 
            display: inline-block; 
            position: relative;
            transition: color 0.1s, background-color 0.1s;
        }
        
        /* New character feedback styles */
        .word.current .char.correct-char { color: var(--primary-color); }
        .word.current .char.incorrect-char {
            color: var(--error-color);
            background-color: rgba(244, 67, 54, 0.2);
            border-radius: 2px;
        }
        .extra-char {
            display: inline-block;
            color: var(--error-color);
            background-color: rgba(244, 67, 54, 0.2);
            border-radius: 2px;
        }
        
        .caret {
            position: absolute;
            width: 2px;
            background-color: var(--caret-color);
            animation: blink 1s infinite;
            transition: left 0.05s linear, top 0.05s linear;
            border-radius: 1px;
            height: calc(1.5rem * 1.4); /* Make caret slightly taller than text */
        }
        @keyframes blink { 50% { opacity: 0; } }

        #hidden-input {
            position: absolute;
            left: -9999px;
            top: auto;
            width: 1px;
            height: 1px;
            opacity: 0;
        }

        #free-hand-area {
            width: 100%;
            height: 100%;
            flex-grow: 1; /* Make it fill available space */
            background: #111;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1.2rem;
            font-family: inherit;
            resize: none;
            padding: 1rem;
        }

        #submit-test-btn {
            padding: 0.75rem 2rem;
            background-color: var(--error-color);
            color: var(--text-color);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 0 auto;
        }

        /* Color Instructions */
        .color-instructions {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.75rem;
            margin-top: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.8rem;
            color: #ccc;
        }
        .instruction-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .color-box {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        /* === New Laptop/Phone Mode Layouts === */
        #live-typed-display { display: none; }

        body.laptop-mode .container {
            max-height: calc(100vh - 65px - 50px); /* header and footer height */
            padding-bottom: 0;
        }
        body.laptop-mode.practice-active .container {
            max-height: 100vh;
        }
        body.laptop-mode #practice-view {
            flex-grow: 1;
            min-height: 0;
        }
        body.laptop-mode #split-display-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
            gap: 1rem;
        }
        body.laptop-mode #text-display-wrapper,
        body.laptop-mode #live-typed-display {
            flex: 1; /* This ensures both divs share the space equally */
            min-height: 0; /* Crucial for scrolling inside flex items */
            font-size: 1.3rem; /* Slightly smaller for more text */
        }
        body.laptop-mode #live-typed-display {
            display: block !important;
        }
        body.laptop-mode #practice-view.free-hand-active #split-display-container {
            display: none;
        }
        body.laptop-mode #practice-view.free-hand-active #free-hand-area {
            display: block !important;
            flex-grow: 1;
        }
        
        /* New Results Modal */
        #results-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
            padding: 1rem;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #results-modal.active {
            display: flex;
        }

        .results-content {
            background-color: #2a2a2e;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            width: 100%;
            max-width: 850px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            color: #e0e0e0;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
        }
        
        .result-card {
            background-color: #333338;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid #444;
            text-align: left;
        }

        .result-card .title {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 0.5rem;
        }

        .result-card .value {
            font-size: 1.75rem;
            font-weight: 700;
            color: #fff;
        }
         .result-card.qualified .value {
            color: var(--primary-color);
        }
         .result-card.not-qualified .value {
            color: var(--error-color);
        }

        .results-formula-note {
            background-color: #333338;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            text-align: left;
            color: #c0c0c0;
            white-space: pre-wrap;
            line-height: 1.6;
        }
        .results-formula-note code {
            color: #fff;
            font-weight: bold;
            background-color: #1e1e1e;
            padding: 0.1em 0.3em;
            border-radius: 3px;
        }
        .results-comparison {
            text-align: left;
        }
        .comparison-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .comparison-passages {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            height: 150px;
        }

        .passage-display {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            font-family: inherit;
            overflow-y: auto;
            text-align: left;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative; /* For caret positioning */
        }
        
        .passage-display span {
            border-radius: 2px;
            padding: 1px 0;
        }

        .correct-word {
            color: var(--primary-color);
        }
        .wrong-word {
            color: var(--error-color);
            background-color: rgba(244, 67, 54, 0.2);
            text-decoration: line-through;
        }
        .half-mistake-word {
            color: #FFA500; /* Orange */
            background-color: rgba(255, 165, 0, 0.2);
            text-decoration: underline;
            text-decoration-style: wavy;
        }
        .omitted-word {
            background-color: rgba(244, 67, 54, 0.3);
            border-radius: 3px;
            padding: 0 2px;
        }


        .results-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            border-top: 1px solid var(--border-color);
            padding-top: 1.5rem;
            position: sticky;
            bottom: -1.5rem;
            background-color: #2a2a2e;
            margin-left: -1.5rem;
            margin-right: -1.5rem;
            padding-left: 1.5rem;
            padding-right: 1.5rem;
            padding-bottom: 1.5rem;
        }

        .results-actions button {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: #222;
            color: var(--text-color);
            font-family: var(--font-family);
            cursor: pointer;
        }

        /* New styles for analytics */
        #mistakes-analysis ul, #improvement-tips ul {
            list-style: none;
            padding-left: 0;
            margin-top: 0.5rem;
        }
        #mistakes-analysis li, #improvement-tips li {
            margin-bottom: 0.5rem;
        }
        #mistakes-analysis ul {
            padding-left: 1rem;
            list-style: '‚Üí ';
        }
        #improvement-tips li {
            padding-left: 1.5rem;
            position: relative;
        }
        #improvement-tips li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 2px;
        }

        .mistake-word {
            color: var(--error-color);
            font-weight: bold;
        }
        .suggestion-word {
            color: var(--primary-color);
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .learn-more-link {
            display: block;
            text-align: center;
            margin-top: 1rem;
            color: var(--primary-color);
            cursor: pointer;
            text-decoration: underline;
            font-size: 0.9rem;
        }
        .learn-more-link:hover {
            color: #66bb6a;
        }
        
        @media (min-width: 768px) {
             .charts-container {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .results-grid { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            .result-card .value { font-size: 1.5rem; }
            .comparison-passages { grid-template-columns: 1fr; height: 250px; }
        }

        @media (max-width: 600px) {
            header h1 { font-size: 1.2rem; }
            .setup-grid { grid-template-columns: 1fr; }
            #text-display-wrapper { font-size: 1.2rem; height: 200px; }
            .stat-item .value { font-size: 1rem; }
            .results-header { flex-direction: column; align-items: flex-start; gap: 0.5rem; }
            .results-content { padding: 1rem; }
            .results-actions {
                bottom: -1rem;
                margin-left: -1rem;
                margin-right: -1rem;
                padding-left: 1rem;
                padding-right: 1rem;
                padding-bottom: 1rem;
            }
            .results-grid { 
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }
            .result-card {
                padding: 0.5rem;
            }
            .result-card .title {
                font-size: 0.7rem;
            }
            .result-card .value {
                font-size: 1.1rem;
                word-break: break-all;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="container header-content">
            <h1>ExamYatri Typing</h1>
            <div class="language-switch">
                <button id="lang-english-btn" class="lang-btn active" data-lang="en">English</button>
                <button id="lang-hindi-btn" class="lang-btn" data-lang="hi">‡§π‡§ø‡§Ç‡§¶‡•Ä</button>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- Setup View -->
        <section id="setup-view" class="view active">
             <div class="mode-toggle-container">
                <button id="laptop-mode-btn" class="mode-toggle-btn">üíª Laptop Mode</button>
                <button id="phone-mode-btn" class="mode-toggle-btn">üì± Phone Mode</button>
            </div>
            <div class="setup-grid">
                <div class="setup-card">
                    <label for="level-select">Select Practice Type</label>
                    <select id="level-select" class="custom-select"></select>
                </div>
                <div class="setup-card" id="method-card">
                    <label for="method-select">Practice Method</label>
                    <select id="method-select" class="custom-select"></select>
                </div>
                <div class="setup-card" id="duration-card">
                    <label for="duration-select">Duration</label>
                    <select id="duration-select" class="custom-select">
                        <option value="1">1 Minute</option>
                        <option value="2">2 Minutes</option>
                        <option value="5" selected>5 Minutes</option>
                        <option value="10">10 Minutes</option>
                        <option value="15">15 Minutes</option>
                        <option value="30">30 Minutes</option>
                    </select>
                </div>
            </div>
            <div id="paste-text-container" style="display: none; width: 100%; margin-bottom: 1rem;">
                <label for="paste-text-area" style="text-align: left; font-size: 0.9rem; color: #ccc; margin-bottom: 0.5rem; display: block;">Paste your text below:</label>
                <textarea id="paste-text-area" style="width: 100%; height: 150px; background: #111; color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; font-family: inherit; font-size: 1rem; padding: 0.75rem; resize: vertical;"></textarea>
            </div>
            <p id="loading-status"></p>
            <button id="start-practice-btn">Start Practice</button>
        </section>

        <!-- Practice View -->
        <section id="practice-view" class="view">
            <div class="stats-dashboard" style="display: flex;">
                <div class="stat-item"><span class="label">Time:</span><span id="stat-time" class="value">00:00</span></div>
                <div class="stat-item"><span class="label">Gross WPM:</span><span id="stat-gross-wpm" class="value">0</span></div>
                <div class="stat-item"><span class="label">Net WPM:</span><span id="stat-net-wpm" class="value">0</span></div>
                <div class="stat-item"><span class="label">Errors:</span><span id="stat-errors" class="value">0</span></div>
                <div class="stat-item"><span class="label">Accuracy:</span><span id="stat-accuracy" class="value">100%</span></div>
            </div>
            <div id="split-display-container">
                <div id="text-display-wrapper" style="display: block;">
                    <div id="text-display"></div>
                    <div id="caret" class="caret" style="display: none;"></div>
                </div>
                <div id="live-typed-display" class="passage-display" aria-readonly="true" role="textbox" aria-label="Your Typed Passage"></div>
            </div>
            <textarea id="free-hand-area" style="display: none;" placeholder="Start typing..."></textarea>
            <div class="color-instructions">
                <span class="instruction-item"><span class="color-box" style="background-color: var(--primary-color);"></span>Correct</span>
                <span class="instruction-item"><span class="color-box" style="background-color: var(--error-color);"></span>Full Mistake</span>
                <span class="instruction-item"><span class="color-box" style="background-color: #FFA500;"></span>Half Mistake</span>
                <span class="instruction-item"><span class="color-box" style="background-color: rgba(136, 136, 136, 0.4);"></span>Omitted</span>
                <span class="instruction-item"><span class="color-box" style="background-color: var(--current-word-bg);"></span>Current</span>
            </div>
            <button id="submit-test-btn">Submit Now</button>
        </section>
    </main>

    <!-- New Results Modal -->
    <div id="results-modal">
        <div class="results-content">
            <div class="results-header">
                <div><strong>Passage Title:</strong> <span id="res-passage-title">N/A</span></div>
                <div><strong>Time Duration:</strong> <span id="res-time-duration">00:00</span> min.</div>
                <div><strong>Time Taken:</strong> <span id="res-time-taken">00:00</span> min.</div>
            </div>
            <div class="results-grid">
                <div class="result-card">
                    <div class="title">Total Keystrokes / Words Typed</div>
                    <div class="value"><span id="res-keystrokes">0</span> / <span id="res-words-typed">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Full Mistake (Words)</div>
                    <div class="value"><span id="res-full-mistakes">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Half Mistake (Words)</div>
                    <div class="value"><span id="res-half-mistakes">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Total Wrong Words</div>
                    <div class="value"><span id="res-total-wrong-words">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Accuracy</div>
                    <div class="value"><span id="res-accuracy">0.00</span>%</div>
                </div>
                <div class="result-card">
                    <div class="title">Gross Typing Speed (wpm)</div>
                    <div class="value"><span id="res-gross-speed">0.00</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Net Typing Speed (wpm)</div>
                    <div class="value"><span id="res-net-speed">0.00</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Backspace Count</div>
                    <div class="value"><span id="res-backspace-count">0</span></div>
                </div>
                <div id="res-result-card" class="result-card">
                    <div class="title">Result</div>
                    <div class="value"><span id="res-result-text">N/A</span></div>
                </div>
            </div>
            <div class="results-formula-note">
                <span id="res-formula-note"></span>
            </div>
             <div id="res-keystroke-warning" style="color: var(--error-color); text-align: center; font-size: 0.9rem; margin-top: 1rem;"></div>
            
             <div id="practice-duration-summary" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Practice Duration Summary</div>
                <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 1rem; font-size: 0.9rem; color: #e0e0e0; padding-top: 0.5rem;">
                    <div>Today's Practice: <strong id="res-today-practice-time" style="color: #fff; font-weight: bold;">0m 0s</strong></div>
                    <div>Total on Device: <strong id="res-total-practice-time" style="color: #fff; font-weight: bold;">0h 0m 0s</strong></div>
                </div>
            </div>
            
            <!-- New Analytics Sections -->
            <div id="weakness-analysis-section" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Common Mistakes & Weak Areas</div>
                <div id="mistakes-analysis" style="font-size: 0.9rem; color: #e0e0e0;">
                    <div id="english-mistakes-container" style="display: none; margin-bottom: 1rem;">
                        <h4 style="color: #ccc; margin-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.25rem;">English Mistakes</h4>
                        <div id="english-mistakes-list"></div>
                    </div>
                    <div id="hindi-mistakes-container" style="display: none;">
                        <h4 style="color: #ccc; margin-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.25rem;">Hindi Mistakes</h4>
                        <div id="hindi-mistakes-list"></div>
                    </div>
                </div>
            </div>
            
            <div id="progress-graphs-section" style="display: none;">
                <h3 style="text-align: left; margin: 1rem 0 0.5rem; color: #e0e0e0;">Your Progress (Last 10 Tests)</h3>
                <div class="charts-container">
                    <canvas id="speed-chart"></canvas>
                    <canvas id="accuracy-chart"></canvas>
                </div>
            </div>

            <div class="results-comparison">
                <div class="comparison-toggle">
                    <label for="comparison-switch">Detailed Comparison</label>
                    <input type="checkbox" id="comparison-switch" checked>
                </div>
                <div class="comparison-passages">
                    <div id="res-original-passage" class="passage-display" aria-readonly="true" role="textbox" aria-label="Original Passage"></div>
                    <div id="res-typed-passage" class="passage-display" aria-readonly="true" role="textbox" aria-label="Typed Passage"></div>
                </div>
            </div>
            <div class="results-actions">
                <button id="retry-test-btn">Retry Same Test</button>
                <button id="new-test-btn">Next Practice Text</button>
                <button id="back-to-home-btn">Back to Home</button>
            </div>
        </div>
    </div>

    <textarea id="hidden-input" autofocus autocapitalize="none" autocorrect="off"></textarea>
    
    <footer style="margin-top: auto; padding: 1rem 0; font-size: 0.9rem; color: #888; border-top: 1px solid var(--border-color); display:none;">
        Visitor Count: <span id="visitCount">0</span>
    </footer>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const autoShiftEnabled = false;
            const lookahead = 4;
            const maxCharsForSmoothPerformance = 8000;
            const INITIAL_RENDER_WORDS = 100;
            const APPEND_WORDS_THRESHOLD = 25;
            const APPEND_WORDS_COUNT = 50;
            
            const RSS_PROXY_URL = 'https://api.rss2json.com/v1/api.json?rss_url=';
            const RSS_FEEDS = {
                en: {
                    primary: 'https://pib.gov.in/RssFeedEnglish.aspx',
                    fallbacks: [
                        'https://indianexpress.com/section/education/feed/',
                        'https://timesofindia.indiatimes.com/rssfeeds/913168846.cms',
                        'https://www.hindustantimes.com/rss/education/rssfeed.xml',
                        'https://www.indiatoday.in/rss/1206578',
                        'https://www.thehindu.com/education/feeder/default.rss'
                    ]
                },
                hi: {
                    primary: 'https://pib.gov.in/RssFeedHindi.aspx',
                    fallbacks: [
                        'https://jansatta.com/education/feed/',
                        'https://navbharattimes.indiatimes.com/education/rssfeed.cms',
                        'https://www.livehindustan.com/rss/career/news.xml',
                        'https://www.aajtak.in/rss/education'
                    ]
                }
            };

            const dom = {
                setupView: document.getElementById('setup-view'),
                practiceView: document.getElementById('practice-view'),
                levelSelect: document.getElementById('level-select'),
                methodSelect: document.getElementById('method-select'),
                durationSelect: document.getElementById('duration-select'),
                methodCard: document.getElementById('method-card'),
                durationCard: document.getElementById('duration-card'),
                loadingStatus: document.getElementById('loading-status'),
                startBtn: document.getElementById('start-practice-btn'),
                pasteTextContainer: document.getElementById('paste-text-container'),
                pasteTextArea: document.getElementById('paste-text-area'),

                mode: {
                    laptopBtn: document.getElementById('laptop-mode-btn'),
                    phoneBtn: document.getElementById('phone-mode-btn'),
                },
                
                stats: {
                    dashboard: document.querySelector('.stats-dashboard'),
                    time: document.getElementById('stat-time'),
                    grossWpm: document.getElementById('stat-gross-wpm'),
                    netWpm: document.getElementById('stat-net-wpm'),
                    errors: document.getElementById('stat-errors'),
                    accuracy: document.getElementById('stat-accuracy'),
                },
                
                splitDisplayContainer: document.getElementById('split-display-container'),
                textDisplayWrapper: document.getElementById('text-display-wrapper'),
                textDisplay: document.getElementById('text-display'),
                liveTypedDisplay: document.getElementById('live-typed-display'),
                caret: document.getElementById('caret'),
                hiddenInput: document.getElementById('hidden-input'),
                freeHandArea: document.getElementById('free-hand-area'),
                submitBtn: document.getElementById('submit-test-btn'),

                resultsModal: document.getElementById('results-modal'),
                newResults: {
                    passageTitle: document.getElementById('res-passage-title'),
                    timeDuration: document.getElementById('res-time-duration'),
                    timeTaken: document.getElementById('res-time-taken'),
                    keystrokes: document.getElementById('res-keystrokes'),
                    wordsTyped: document.getElementById('res-words-typed'),
                    fullMistakes: document.getElementById('res-full-mistakes'),
                    halfMistakes: document.getElementById('res-half-mistakes'),
                    totalWrongWords: document.getElementById('res-total-wrong-words'),
                    accuracy: document.getElementById('res-accuracy'),
                    grossSpeed: document.getElementById('res-gross-speed'),
                    netSpeed: document.getElementById('res-net-speed'),
                    backspaceCount: document.getElementById('res-backspace-count'),
                    resultCard: document.getElementById('res-result-card'),
                    resultText: document.getElementById('res-result-text'),
                    originalPassage: document.getElementById('res-original-passage'),
                    typedPassage: document.getElementById('res-typed-passage'),
                    formulaNote: document.getElementById('res-formula-note'),
                },
                resultActions: {
                    retry: document.getElementById('retry-test-btn'),
                    newTest: document.getElementById('new-test-btn'),
                    backToHome: document.getElementById('back-to-home-btn'),
                },
                langEnglishBtn: document.getElementById('lang-english-btn'),
                langHindiBtn: document.getElementById('lang-hindi-btn'),
            };
            
            const TEXT_RESOURCES = {
                en: {
                    simple: "the quick brown fox jumps over the lazy dog a cat sat on the mat i can see a big red car we like to play at the park my dog has a long tail birds can fly high in the sky the green frog jumps fish swim in the water",
                    complex: "Bureaucracy, often criticized for its inefficiency, serves as a fundamental framework for implementing governmental policies. The intricate labyrinth of regulations requires meticulous navigation. Simultaneously, the proliferation of quantum computing threatens contemporary cryptographic standards, necessitating the development of post-quantum algorithms to safeguard digital infrastructure.",
                    wordSets: {
                        home: ["a", "add", "all", "ask", "ash", "dad", "fall", "fad", "flag", "flash", "flask", "gad", "gas", "glad", "glass", "had", "has", "jag", "lad", "lass", "sad", "sagas", "salsa", "shall"],
                        top: ["we", "were", "to", "try", "true", "pout", "power", "priority", "query", "quote", "ripe", "tier", "trip", "type", "your", "yet", "wet", "erupt"],
                        bottom: ["zoo", "box", "ban", "cab", "man", "van", "max", "vex", "mix", "calm", "zoom", "zebra", "mob", "nab"],
                    }
                },
                hi: {
                    simple: "‡§∞‡§æ‡§Æ ‡§ò‡§∞ ‡§ó‡§Ø‡§æ ‡§∏‡•Ä‡§§‡§æ ‡§ñ‡§æ‡§®‡§æ ‡§ñ‡§æ‡§§‡•Ä ‡§π‡•à ‡§Æ‡•ã‡§π‡§® ‡§∏‡•ç‡§ï‡•Ç‡§≤ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§Ø‡§π ‡§è‡§ï ‡§ï‡§ø‡§§‡§æ‡§¨ ‡§π‡•à ‡§∏‡•Ç‡§∞‡§ú ‡§™‡•Ç‡§∞‡§¨ ‡§Æ‡•á‡§Ç ‡§â‡§ó‡§§‡§æ ‡§π‡•à ‡§¨‡§ö‡•ç‡§ö‡•á ‡§Æ‡•à‡§¶‡§æ‡§® ‡§Æ‡•á‡§Ç ‡§ñ‡•á‡§≤‡§§‡•á ‡§π‡•à‡§Ç",
                    complex: "‡§Ü‡§ß‡•Å‡§®‡§ø‡§ï ‡§™‡•ç‡§∞‡•å‡§¶‡•ç‡§Ø‡•ã‡§ó‡§ø‡§ï‡•Ä ‡§®‡•á ‡§π‡§Æ‡§æ‡§∞‡•á ‡§ú‡•Ä‡§µ‡§® ‡§ï‡•ã ‡§Ö‡§≠‡•Ç‡§§‡§™‡•Ç‡§∞‡•ç‡§µ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§¨‡§¶‡§≤ ‡§¶‡§ø‡§Ø‡§æ ‡§π‡•à‡•§ ‡§µ‡•à‡§∂‡•ç‡§µ‡•Ä‡§ï‡§∞‡§£ ‡§ï‡•á ‡§á‡§∏ ‡§Ø‡•Å‡§ó ‡§Æ‡•á‡§Ç, ‡§µ‡§ø‡§≠‡§ø‡§®‡•ç‡§® ‡§∏‡§Ç‡§∏‡•ç‡§ï‡•É‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡§æ ‡§Ü‡§¶‡§æ‡§®-‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§î‡§∞ ‡§∏‡§Æ‡§®‡•ç‡§µ‡§Ø ‡§Ö‡§§‡•ç‡§Ø‡§Ç‡§§ ‡§Æ‡§π‡§§‡•ç‡§µ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§∏‡§Ç‡§µ‡§ø‡§ß‡§æ‡§® ‡§®‡§æ‡§ó‡§∞‡§ø‡§ï‡•ã‡§Ç ‡§ï‡•ã ‡§Æ‡•å‡§≤‡§ø‡§ï ‡§Ö‡§ß‡§ø‡§ï‡§æ‡§∞ ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, ‡§ú‡§ø‡§®‡§ï‡•Ä ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§æ ‡§®‡•ç‡§Ø‡§æ‡§Ø‡§™‡§æ‡§≤‡§ø‡§ï‡§æ ‡§ï‡§æ ‡§¶‡§æ‡§Ø‡§ø‡§§‡•ç‡§µ ‡§π‡•à‡•§",
                    wordSets: {
                         home: ["‡§ï‡§≤", "‡§Ü‡§ú", "‡§§‡§ï", "‡§™‡§∞", "‡§∏‡§π‡§ú", "‡§∏‡§∞‡§≤", "‡§è‡§ï", "‡§≤‡§π‡§∞", "‡§∏‡§∞‡§∏", "‡§Ø‡§π", "‡§ú‡§≤", "‡§ò‡§∞", "‡§´‡§≤"],
                         top: ["‡§Æ‡§§", "‡§ö‡§≤", "‡§ú‡§ó", "‡§ú‡§¨", "‡§ü‡§¨", "‡§ü‡§Æ‡§ü‡§Æ", "‡§™‡§∞", "‡§ö‡•ù", "‡§§‡§¨", "‡§≠‡§∞", "‡§ã‡§£", "‡§§‡§ü"],
                         bottom: ["‡§µ‡§®", "‡§Æ‡§®", "‡§ß‡§®", "‡§¨‡§Æ", "‡§ï‡§Æ", "‡§®‡§Æ", "‡§Ö‡§¨", "‡§ï‡§¨", "‡§è‡§ï", "‡§¶‡§Æ"],
                    }
                }
            };
            
            let appState = {};
            let practiceStartId = 0; // To prevent race conditions on start
            let speedChartInstance, accuracyChartInstance;
            const textCache = {
                en: { status: 'idle', promise: null, text: null },
                hi: { status: 'idle', promise: null, text: null }
            };

            // --- LOCAL STORAGE & ANALYTICS ---
            const storage = {
                get: (key, defaultValue = null) => {
                    try {
                        const item = localStorage.getItem(key);
                        return item ? JSON.parse(item) : defaultValue;
                    } catch (e) {
                        console.warn('LocalStorage disabled:', e);
                        return defaultValue;
                    }
                },
                set: (key, value) => {
                    try {
                        localStorage.setItem(key, JSON.stringify(value));
                    } catch (e) {
                        console.warn('LocalStorage disabled:', e);
                    }
                }
            };

            const MISTAKES_KEY = 'typingMistakes';
            const HISTORY_KEY = 'typingHistory';
            const MAX_HISTORY_ITEMS = 10;

            const updateMistakeHistory = () => {
                const mistakesData = storage.get(MISTAKES_KEY, { en: {}, hi: {} });
                const langMistakes = mistakesData[appState.lang] || {};

                appState.session.wordStates.forEach(state => {
                    if ((state.status === 'wrong' || state.status === 'half') && state.ref && state.typed) {
                        const ref = state.ref.toLowerCase();
                        if (!langMistakes[ref]) {
                            langMistakes[ref] = { count: 0, typedAs: {} };
                        }
                        langMistakes[ref].count++;
                        const typed = state.typed.toLowerCase();
                        langMistakes[ref].typedAs[typed] = (langMistakes[ref].typedAs[typed] || 0) + 1;
                    }
                });
                mistakesData[appState.lang] = langMistakes;
                storage.set(MISTAKES_KEY, mistakesData);
            };
            
            const renderMistakeAnalysis = () => {
                const mistakesData = storage.get(MISTAKES_KEY, { en: {}, hi: {} });
                
                ['en', 'hi'].forEach(lang => {
                    const langMistakes = mistakesData[lang];
                    const containerId = lang === 'en' ? 'english-mistakes-container' : 'hindi-mistakes-container';
                    const listId = lang === 'en' ? 'english-mistakes-list' : 'hindi-mistakes-list';
                    const container = document.getElementById(containerId);
                    const listEl = document.getElementById(listId);

                    const sortedMistakes = Object.entries(langMistakes || {})
                        .sort(([, a], [, b]) => b.count - a.count)
                        .slice(0, 5); // Show top 5

                    if (sortedMistakes.length > 0) {
                        listEl.innerHTML = `<ul>${sortedMistakes.map(([word, data]) => {
                            const typedEntries = Object.entries(data.typedAs || {});
                            const mostCommonTyped = typedEntries.length ? typedEntries.sort(([, a], [, b]) => b - a)[0][0] : '(no examples)';
                            return `<li>You mistyped <span class="mistake-word">'${word}'</span> as <span class="suggestion-word">'${mostCommonTyped}'</span> (${data.count} times total)</li>`;
                        }).join('')}</ul>`;
                        container.style.display = 'block';
                    } else {
                         listEl.innerHTML = `<p>No common mistakes recorded yet for this language.</p>`;
                         container.style.display = 'block';
                    }
                });
                
                document.getElementById('weakness-analysis-section').style.display = 'block';
            };

            const updatePracticeHistory = (finalMetrics) => {
                const history = storage.get(HISTORY_KEY, []);
                history.push({
                    lang: appState.lang,
                    netWPM: finalMetrics.netWPM,
                    accuracy: finalMetrics.accuracyPercent,
                    timestamp: new Date().toISOString()
                });
                if (history.length > MAX_HISTORY_ITEMS) {
                    history.shift();
                }
                storage.set(HISTORY_KEY, history);
            };
            
            const renderProgressGraphs = () => {
                const history = storage.get(HISTORY_KEY, []);
                const graphSection = document.getElementById('progress-graphs-section');
                if (history.length < 2) {
                    graphSection.style.display = 'none';
                    return;
                }

                graphSection.style.display = 'block';

                const labels = history.map((_, i) => `Test ${i + 1}`);
                const speedData = history.map(item => Math.round(item.netWPM));
                const accuracyData = history.map(item => Number(item.accuracy) || 0);

                const speedCtx = document.getElementById('speed-chart').getContext('2d');
                if (speedChartInstance) speedChartInstance.destroy();
                speedChartInstance = new Chart(speedCtx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Net WPM',
                            data: speedData,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: { display: true, text: 'Net Speed (WPM) Trend', color: '#fff' },
                            tooltip: { callbacks: { label: (context) => `${context.dataset.label}: ${context.raw} (Lang: ${history[context.dataIndex].lang.toUpperCase()})` } }
                        },
                        scales: { y: { beginAtZero: true, ticks: { color: '#ccc' }, grid: { color: '#444' } }, x: { ticks: { color: '#ccc' }, grid: { color: '#444' } } }
                    }
                });

                const accuracyCtx = document.getElementById('accuracy-chart').getContext('2d');
                if (accuracyChartInstance) accuracyChartInstance.destroy();
                accuracyChartInstance = new Chart(accuracyCtx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Accuracy %',
                            data: accuracyData,
                            borderColor: 'rgba(255, 159, 64, 1)',
                            backgroundColor: 'rgba(255, 159, 64, 0.2)',
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: { display: true, text: 'Accuracy (%) Trend', color: '#fff' },
                            tooltip: { callbacks: { label: (context) => `${context.dataset.label}: ${context.raw}% (Lang: ${history[context.dataIndex].lang.toUpperCase()})` } }
                        },
                        scales: { y: { min: 0, max: 100, ticks: { color: '#ccc' }, grid: { color: '#444' } }, x: { ticks: { color: '#ccc' }, grid: { color: '#444' } } }
                    }
                });
            };

            const triggerCelebration = () => {
                const modal = dom.resultsModal;
                if (!modal) return;
                let container = document.getElementById('celebration-container');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'celebration-container';
                    container.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 1001;';
                    modal.appendChild(container);
                }
                container.innerHTML = '';
                const emojis = ['üéâ', 'üéä', 'ü•≥', 'üëè', 'üèÜ', '‚ú®'];
                for (let i = 0; i < 50; i++) {
                    const emoji = document.createElement('span');
                    emoji.innerHTML = emojis[Math.floor(Math.random() * emojis.length)];
                    emoji.style.cssText = `position: absolute; font-size: ${Math.random() * 2 + 1}rem; left: ${Math.random() * 100}%; top: ${Math.random() * 100}%; opacity: 1; transition: transform 3s ease-out, opacity 3s ease-out;`;
                    container.appendChild(emoji);
                    setTimeout(() => {
                        const x = (Math.random() - 0.5) * 600;
                        const y = (Math.random() - 0.5) * 600;
                        emoji.style.transform = `translate(${x}px, ${y}px) rotate(${Math.random() * 720}deg)`;
                        emoji.style.opacity = '0';
                    }, 10);
                    setTimeout(() => { if (container && emoji.parentNode === container) container.removeChild(emoji) }, 3010);
                }
            };
            
            // --- TEXT GENERATORS & FETCHING ---
            const fetchPracticeText = async (language = 'en') => {
                const feeds = RSS_FEEDS[language];
                const urlsToTry = [feeds.primary, ...feeds.fallbacks.sort(() => 0.5 - Math.random())];

                for (const url of urlsToTry) {
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                        
                        const fetchUrl = `${RSS_PROXY_URL}${encodeURIComponent(url)}&_=${new Date().getTime()}`;
                        const response = await fetch(fetchUrl, { cache: "no-cache", signal: controller.signal });
                        clearTimeout(timeoutId);

                        if (!response.ok) {
                            console.warn(`Network error fetching from ${url}. Status: ${response.status}`);
                            continue;
                        }
                        const data = await response.json();
                        if (data.status !== 'ok' || !data.items || data.items.length === 0) {
                            console.warn(`API error or no items from ${url}. Status: ${data.status}`);
                            continue;
                        }
                        const randomArticle = data.items[Math.floor(Math.random() * data.items.length)];
                        const description = randomArticle.description || randomArticle.content || '';
                        let text = `${randomArticle.title}. ${description}`;

                        const tempEl = document.createElement('div');
                        tempEl.innerHTML = text;
                        text = tempEl.textContent || tempEl.innerText || '';
                        
                        text = text.replace(/<[^>]+>/g, '').replace(/\s\s+/g, ' ').replace(/\[read more\]/gi, '').replace(/Read More ¬ª/gi, '').trim();
                        
                        if (text.length > 200) {
                            console.log(`Successfully fetched text from ${url}`);
                            return text;
                        }
                    } catch (err) {
                         if (err.name === 'AbortError') {
                            console.warn(`Fetch from ${url} timed out.`);
                        } else {
                            console.error(`Error fetching or parsing from ${url}:`, err);
                        }
                    }
                }
                console.warn("All RSS sources failed, using offline complex text as fallback.");
                return TEXT_RESOURCES[language].complex.repeat(5);
            };

            const prefetchArticle = async (language) => {
                if (textCache[language].status === 'fetching' || textCache[language].status === 'ready') return;

                textCache[language].status = 'fetching';
                textCache[language].promise = fetchPracticeText(language);
                
                try {
                    const text = await textCache[language].promise;
                    textCache[language].text = text;
                    textCache[language].status = 'ready';
                    const currentLang = dom.langEnglishBtn.classList.contains('active') ? 'en' : 'hi';
                    if (language === currentLang && dom.loadingStatus.textContent.includes('Fetching')) {
                         dom.loadingStatus.textContent = 'Ready to start!';
                         setTimeout(() => { if (dom.loadingStatus.textContent === 'Ready to start!') dom.loadingStatus.textContent = ''; }, 2000);
                    }
                } catch (error) {
                    console.error(`Pre-fetching failed for ${language}:`, error);
                    textCache[language].status = 'idle';
                    textCache[language].text = null;
                } finally {
                    textCache[language].promise = null;
                }
            };
            
            const getArticleForPractice = async (language) => {
                const cache = textCache[language];

                // If an article was successfully pre-fetched, use it and then start fetching the next one.
                if (cache.status === 'ready' && cache.text) {
                    const text = cache.text;
                    cache.text = null; // Invalidate the used text
                    cache.status = 'idle'; // Reset status to allow a new prefetch
                    prefetchArticle(language); // Start fetching the *next* article immediately
                    return text;
                }

                // If a pre-fetch is already in progress, wait for it to finish.
                if (cache.status === 'fetching' && cache.promise) {
                    dom.loadingStatus.textContent = 'Finalizing your practice text...';
                    const text = await cache.promise;
                    cache.text = null; // Invalidate after use
                    cache.status = 'idle';
                    prefetchArticle(language); // Start fetching the *next* article
                    return text;
                }
                
                // If no article is ready (e.g., first load or failed prefetch), fetch one on demand.
                dom.loadingStatus.textContent = 'Fetching a new article...';
                const text = await fetchPracticeText(language);
                prefetchArticle(language); // Also trigger a pre-fetch for the session after this one
                return text;
            };

            const generateTextFromWords = (wordList, count = 200) => {
                let text = [];
                for (let i = 0; i < count; i++) {
                    text.push(wordList[Math.floor(Math.random() * wordList.length)]);
                }
                return text.join(' ');
            };

            const practiceLevels = {
                "Beginner": {
                    "Home Row": () => Promise.resolve(generateTextFromWords(TEXT_RESOURCES[appState.lang].wordSets.home)),
                    "Top Row": () => Promise.resolve(generateTextFromWords(TEXT_RESOURCES[appState.lang].wordSets.top)),
                    "Bottom Row": () => Promise.resolve(generateTextFromWords(TEXT_RESOURCES[appState.lang].wordSets.bottom)),
                    "Home + Top": () => Promise.resolve(generateTextFromWords([...TEXT_RESOURCES[appState.lang].wordSets.home, ...TEXT_RESOURCES[appState.lang].wordSets.top])),
                    "Home + Bottom": () => Promise.resolve(generateTextFromWords([...TEXT_RESOURCES[appState.lang].wordSets.home, ...TEXT_RESOURCES[appState.lang].wordSets.bottom])),
                    "Top + Bottom": () => Promise.resolve(generateTextFromWords([...TEXT_RESOURCES[appState.lang].wordSets.top, ...TEXT_RESOURCES[appState.lang].wordSets.bottom])),
                    "Small Sentences": () => getArticleForPractice(appState.lang).then(text => {
                        const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
                        const shortSentences = sentences.filter(s => tokenize(s).length < 15 && tokenize(s).length > 3);
                        return (shortSentences.length < 5) ? TEXT_RESOURCES[appState.lang].simple.repeat(10) : shortSentences.sort(() => 0.5 - Math.random()).slice(0, 10).join(' ');
                    }),
                },
                "Skill Building": {
                    "Random Words": () => getArticleForPractice(appState.lang).then(text => tokenize(text).sort(() => 0.5 - Math.random()).join(' ')),
                    "Sentence Practice": () => getArticleForPractice(appState.lang),
                    "Paragraph Practice": () => getArticleForPractice(appState.lang),
                    "Punctuation Practice": () => getArticleForPractice(appState.lang),
                },
                "Exam": { 
                    "All Exam": () => getArticleForPractice(appState.lang), 
                },
                "Free Hand": { "Start Typing": () => Promise.resolve("This is a free hand session.") },
                "Paste Your Text": { "Start Practice": () => Promise.resolve(dom.pasteTextArea.value) }
            };

            // --- UTILITY FUNCTIONS ---
            const graphemeSplitter = (text) => {
                if (typeof Intl.Segmenter === 'function') {
                    try {
                        const segmenter = new Intl.Segmenter(appState.lang, { granularity: 'grapheme' });
                        return Array.from(segmenter.segment(text)).map(g => g.segment);
                    } catch (e) { return Array.from(text); }
                }
                return Array.from(text);
            };

            const levenshtein = (a, b) => {
              if (a === b) return 0;
              const n = a.length, m = b.length;
              if (n === 0) return m; if (m === 0) return n;
              let prev = Array(m + 1).fill(0).map((_, j) => j);
              let cur = Array(m + 1).fill(0);
              for (let i = 1; i <= n; i++) {
                cur[0] = i;
                for (let j = 1; j <= m; j++) {
                  const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                  cur[j] = Math.min(prev[j] + 1, cur[j - 1] + 1, prev[j - 1] + cost);
                }
                [prev, cur] = [cur, prev];
              }
              return prev[m];
            };

            const tokenize = (text) => text.normalize("NFC").trim().split(/\s+/).filter(Boolean);

            // --- STATE MANAGEMENT ---
            const resetState = () => {
                if (typeof appState !== 'undefined' && appState.timerId) {
                    clearInterval(appState.timerId);
                }
                appState = {
                    lang: 'en',
                    timerId: null,
                    isPracticeActive: false,
                    isFetchingMore: false,
                    config: {
                        level: '',
                        method: '',
                        duration: 0,
                        sourceText: '',
                    },
                    session: {
                        startTime: 0,
                        timeLeft: 0,
                        allRefWords: [], 
                        refWords: [], 
                        wordStates: [], 
                        currentWordIndex: 0,
                        backspaceCount: 0,
                        totalKeystrokes: 0,
                        fullMistakes: 0,
                        halfMistakes: 0,
                    },
                };
            };
            
            // --- UI AND RENDERING ---
            const populateLevels = () => { dom.levelSelect.innerHTML = Object.keys(practiceLevels).map(level => `<option value="${level}">${level}</option>`).join(''); };
            const populateMethods = () => { const selectedLevel = dom.levelSelect.value; const methods = Object.keys(practiceLevels[selectedLevel]); dom.methodSelect.innerHTML = methods.map(method => `<option value="${method}">${method}</option>`).join(''); handleLevelChange(); };
            const handleLevelChange = () => {
                const level = dom.levelSelect.value;
                dom.pasteTextContainer.style.display = (level === 'Paste Your Text') ? 'block' : 'none';
                dom.methodCard.style.display = (level === 'Paste Your Text' || level === 'Free Hand') ? 'none' : 'flex';
                dom.durationCard.style.display = (level === 'Free Hand') ? 'none' : 'flex';
            };
            const switchView = (view) => {
                dom.setupView.classList.toggle('active', view === 'setup');
                dom.practiceView.classList.toggle('active', view === 'practice');
                document.body.classList.toggle('practice-active', view === 'practice');
            };
            
            const createWordHtml = (word, index) => {
                 const charsHtml = graphemeSplitter(word).map((char, charIndex) => 
                    `<span class="char" id="word-${index}-char-${charIndex}">${char}</span>`
                ).join('');
                return `<span class="word" id="word-${index}">${charsHtml}<span class="extra-chars-wrapper"></span></span>`;
            };

            const renderWords = () => {
                dom.textDisplay.innerHTML = appState.session.refWords.map(createWordHtml).join('');
                dom.textDisplay.className = appState.lang === 'hi' ? 'hindi' : '';
                updateUI();
            };

            const positionCaretAndScroll = () => {
                if (document.body.classList.contains('laptop-mode')) {
                    // --- LAPTOP MODE ---
                    const liveDisplay = dom.liveTypedDisplay;
                    const caretAnchor = document.getElementById('caret-anchor');
                    
                    if (caretAnchor) {
                        dom.caret.style.display = 'block';
                        const liveDisplayRect = liveDisplay.getBoundingClientRect();
                        const anchorRect = caretAnchor.getBoundingClientRect();
                        
                        const top = anchorRect.top - liveDisplayRect.top + liveDisplay.scrollTop;
                        const left = anchorRect.left - liveDisplayRect.left + liveDisplay.scrollLeft;

                        dom.caret.style.left = `${left}px`;
                        dom.caret.style.top = `${top}px`;
                    } else {
                         dom.caret.style.display = appState.isPracticeActive ? 'block' : 'none';
                         dom.caret.style.left = '0px';
                         dom.caret.style.top = '0px';
                    }
                    liveDisplay.scrollTop = liveDisplay.scrollHeight;
                    
                    const { session } = appState;
                    const currentWordEl = document.getElementById(`word-${session.currentWordIndex}`);
                    if (currentWordEl) {
                        const targetScrollTop = currentWordEl.offsetTop - (dom.textDisplayWrapper.clientHeight * 0.4);
                        if (Math.abs(dom.textDisplayWrapper.scrollTop - targetScrollTop) > 5) {
                            dom.textDisplayWrapper.scrollTo({ top: Math.max(0, targetScrollTop), behavior: 'smooth' });
                        }
                    }
                } else {
                    // --- PHONE MODE ---
                    const { session } = appState;
                    const currentWordEl = document.getElementById(`word-${session.currentWordIndex}`);
                    if (currentWordEl) {
                        dom.caret.style.display = 'block';
                        const typedValue = dom.hiddenInput.value;
                        const typedLength = graphemeSplitter(typedValue).length;
                        
                        let targetEl;
                        let positionAt = 'left';

                        const originalChars = currentWordEl.querySelectorAll('.char');

                        if (typedLength === 0) {
                            targetEl = currentWordEl;
                        } else if (typedLength <= originalChars.length) {
                            targetEl = originalChars[typedLength - 1];
                            positionAt = 'right';
                        } else {
                            const extraChars = currentWordEl.querySelectorAll('.extra-char');
                            const extraIndex = typedLength - originalChars.length - 1;
                            if (extraChars.length > 0 && extraChars[extraIndex]) {
                                targetEl = extraChars[extraIndex];
                                positionAt = 'right';
                            } else {
                                targetEl = originalChars.length > 0 ? originalChars[originalChars.length - 1] : currentWordEl;
                                positionAt = 'right';
                            }
                        }

                        if (!targetEl || !targetEl.getBoundingClientRect) {
                            dom.caret.style.display = 'none';
                        } else {
                            const wrapperRect = dom.textDisplayWrapper.getBoundingClientRect();
                            const targetRect = targetEl.getBoundingClientRect();
                            
                            let left = (positionAt === 'right') 
                                ? (targetRect.right - wrapperRect.left) 
                                : (targetRect.left - wrapperRect.left);
                            
                            const top = targetRect.top - wrapperRect.top + dom.textDisplayWrapper.scrollTop;
                            
                            dom.caret.style.left = `${left}px`;
                            dom.caret.style.top = `${top}px`;
                        }

                        const targetScrollTop = currentWordEl.offsetTop - (dom.textDisplayWrapper.clientHeight * 0.4);
                        if (Math.abs(dom.textDisplayWrapper.scrollTop - targetScrollTop) > 5) {
                            dom.textDisplayWrapper.scrollTo({ top: Math.max(0, targetScrollTop), behavior: 'smooth' });
                        }
                    } else {
                        dom.caret.style.display = 'none';
                    }
                }
            };
            
            const updateLiveStats = () => {
                const elapsedSeconds = appState.session.startTime > 0 ? (Date.now() - appState.session.startTime) / 1000 : 0;
                if (elapsedSeconds <= 0 && appState.isPracticeActive) return;

                const minutes = Math.floor(appState.session.timeLeft / 60);
                const seconds = appState.session.timeLeft % 60;
                dom.stats.time.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                
                let currentKeystrokes = appState.session.totalKeystrokes;
                if (dom.hiddenInput.value) {
                    const typedWord = dom.hiddenInput.value;
                    const baseKeystrokes = appState.session.wordStates
                        .slice(0, appState.session.currentWordIndex)
                        .reduce((sum, s) => sum + (s.typed?.length || 0) + 1, 0);
                    currentKeystrokes = baseKeystrokes + typedWord.length;
                }

                const metrics = window.computeTypingMetrics({
                    timeSeconds: elapsedSeconds > 1 ? elapsedSeconds : 1,
                    keystrokesOverride: currentKeystrokes,
                    fullMistakes: appState.session.fullMistakes,
                    halfMistakes: appState.session.halfMistakes
                });
                
                dom.stats.grossWpm.textContent = metrics.grossWPMDisplay;
                dom.stats.netWpm.textContent = metrics.netWPMDisplay;
                dom.stats.errors.textContent = (metrics.errorPenaltyWords || 0).toFixed(1);
                dom.stats.accuracy.textContent = `${metrics.accuracyDisplay}%`;
            };

            const updateLiveTypedDisplay = () => {
                const { session } = appState;
                let typedHTML = '';
                
                session.wordStates.slice(0, session.currentWordIndex).forEach(state => {
                    const t = state.typed || '';
                    if (state.status === 'omitted') {
                        typedHTML += ` `;
                    } else {
                        const statusClass = { 'correct': 'correct-word', 'wrong': 'wrong-word', 'half': 'half-mistake-word'}[state.status] || '';
                        typedHTML += `<span class="${statusClass}">${t}</span> `;
                    }
                });
                
                const currentTypedWord = dom.hiddenInput.value;
                if (currentTypedWord) {
                    typedHTML += `<span>${currentTypedWord}</span>`;
                }

                typedHTML += '<span id="caret-anchor"></span>';
                dom.liveTypedDisplay.innerHTML = typedHTML;
                dom.liveTypedDisplay.scrollTop = dom.liveTypedDisplay.scrollHeight;
            };

            const updateCurrentWordVisuals = () => {
                const { session } = appState;
                const currentWordEl = document.getElementById(`word-${session.currentWordIndex}`);
                if (!currentWordEl) return;

                const refWord = session.refWords[session.currentWordIndex] || '';
                const typedWord = dom.hiddenInput.value;
                const refChars = graphemeSplitter(refWord);
                const typedChars = graphemeSplitter(typedWord);

                const charElements = currentWordEl.querySelectorAll('.char');
                
                charElements.forEach((charEl, i) => {
                    charEl.classList.remove('correct-char', 'incorrect-char');
                    if (i < typedChars.length) {
                        if (typedChars[i] === refChars[i]) {
                            charEl.classList.add('correct-char');
                        } else {
                            charEl.classList.add('incorrect-char');
                        }
                    }
                });

                const extraCharsWrapper = currentWordEl.querySelector('.extra-chars-wrapper');
                if (extraCharsWrapper) {
                    if (typedChars.length > refChars.length) {
                        const extraText = typedChars.slice(refChars.length).join('');
                        extraCharsWrapper.innerHTML = graphemeSplitter(extraText)
                            .map(char => `<span class="extra-char">${char}</span>`)
                            .join('');
                    } else {
                        extraCharsWrapper.innerHTML = '';
                    }
                }
            };

            const updateUI = () => {
                requestAnimationFrame(() => {
                    if (!appState.isPracticeActive && appState.session.startTime === 0) return;

                    const { session } = appState;
                    session.wordStates.forEach((state, index) => {
                        const el = document.getElementById(`word-${index}`);
                        if(el) {
                            let newClass = 'word';
                            if (index === session.currentWordIndex) newClass += ' current';
                            else if (state.status !== 'untyped') newClass += ` ${state.status}`;
                            if (el.className !== newClass) el.className = newClass;
                        }
                    });

                    if (document.body.classList.contains('laptop-mode')) {
                        updateLiveTypedDisplay();
                    }
                    
                    positionCaretAndScroll();
                    updateLiveStats();
                });
            };

            // --- CORE TYPING LOGIC ---
             const appendMoreWords = () => {
                if (appState.isFetchingMore) return;
                appState.isFetchingMore = true;
                
                const { session } = appState;
                const currentLength = session.refWords.length;
                const nextChunk = session.allRefWords.slice(currentLength, currentLength + APPEND_WORDS_COUNT);

                if (nextChunk.length > 0) {
                    session.refWords.push(...nextChunk);
                    session.wordStates.push(...nextChunk.map(ref => ({ ref, typed: '', status: 'untyped' })));

                    const fragment = document.createDocumentFragment();
                    nextChunk.forEach((word, index) => {
                        const wordEl = document.createElement('span');
                        wordEl.innerHTML = createWordHtml(word, currentLength + index);
                        fragment.appendChild(wordEl.firstChild);
                        fragment.appendChild(document.createTextNode(' '));
                    });
                    dom.textDisplay.appendChild(fragment);
                }
                appState.isFetchingMore = false;
            };

            const startPractice = async () => {
                const currentStartId = ++practiceStartId;
                const level = dom.levelSelect.value;

                if (level === 'Paste Your Text' && dom.pasteTextArea.value.trim() === '') {
                    alert("Please paste your text before starting.");
                    return;
                }
                dom.startBtn.disabled = true;
                
                try {
                    resetState();
                    appState.lang = dom.langEnglishBtn.classList.contains('active') ? 'en' : 'hi';
                    
                    const method = (level === 'Paste Your Text' || level === 'Free Hand') ? 'Start Practice' : dom.methodSelect.value;
                    const textGenerator = practiceLevels[level][method];
                    let sourceText;

                    dom.practiceView.classList.remove('free-hand-active');
                    if (level === 'Free Hand') {
                        appState.config = { level, method, duration: 0, sourceText: '' };
                        switchView('practice');
                        dom.stats.dashboard.style.display = 'none';
                        dom.splitDisplayContainer.style.display = 'none';
                        dom.freeHandArea.style.display = 'block';
                        dom.freeHandArea.value = '';
                        dom.freeHandArea.focus();
                        dom.submitBtn.textContent = 'Back to Setup';
                        dom.practiceView.classList.add('free-hand-active');
                        return;
                    }

                    dom.loadingStatus.textContent = 'Preparing your text...';
                    sourceText = await textGenerator();

                    if (currentStartId !== practiceStartId) {
                        console.log("Aborting stale practice start.");
                        dom.startBtn.disabled = false;
                        return;
                    }
                    
                    if (!sourceText) throw new Error("Failed to get any practice text.");

                    if (sourceText.length > maxCharsForSmoothPerformance) {
                        sourceText = sourceText.substring(0, maxCharsForSmoothPerformance);
                    }
                    
                    appState.config = { level, method, duration: parseInt(dom.durationSelect.value, 10) * 60, sourceText };
                    
                    const allRefWords = tokenize(sourceText);
                    appState.session.allRefWords = allRefWords;
                    appState.session.refWords = allRefWords.slice(0, INITIAL_RENDER_WORDS);
                    appState.session.wordStates = appState.session.refWords.map(ref => ({ ref, typed: '', status: 'untyped' }));
                    appState.session.timeLeft = appState.config.duration;
                    
                    dom.stats.dashboard.style.display = 'flex';
                    dom.splitDisplayContainer.style.display = ''; // Reset display
                    dom.textDisplayWrapper.style.display = 'block';
                    dom.freeHandArea.style.display = 'none';
                    dom.submitBtn.textContent = 'Submit Now';

                    switchView('practice');
                    renderWords();
                    dom.hiddenInput.focus();
                } catch (error) {
                    console.error("Failed to start practice:", error);
                    dom.loadingStatus.textContent = 'Error preparing text. Please try again.';
                } finally {
                    if (dom.loadingStatus.textContent.includes('Preparing')) dom.loadingStatus.textContent = '';
                    dom.startBtn.disabled = false;
                }
            };
            
            const startTimer = () => {
                if (appState.timerId || appState.config.duration <= 0) return;
                appState.timerId = setInterval(() => {
                    if (appState.isPracticeActive) {
                        const elapsed = Math.floor((Date.now() - appState.session.startTime) / 1000);
                        appState.session.timeLeft = appState.config.duration - elapsed;
                        if (appState.session.timeLeft <= 0) {
                            appState.session.timeLeft = 0;
                            endPractice();
                        }
                        if (appState.session.currentWordIndex >= appState.session.refWords.length - APPEND_WORDS_THRESHOLD && appState.session.refWords.length < appState.session.allRefWords.length) {
                             appendMoreWords();
                        }
                        updateLiveStats();
                    }
                }, 250);
            };

            const commitCurrentWord = () => {
                const { session } = appState;
                if (session.currentWordIndex >= session.refWords.length) return;

                const typedWord = dom.hiddenInput.value.trim();
                const refWord = session.refWords[session.currentWordIndex];
                const currentState = session.wordStates[session.currentWordIndex];
                currentState.typed = typedWord;
                
                session.totalKeystrokes += graphemeSplitter(typedWord).length + (typedWord ? 1 : 0);

                if (typedWord === "") {
                    currentState.status = 'omitted';
                    session.fullMistakes++;
                } else {
                    const distance = levenshtein(refWord, typedWord);
                    if (distance === 0) currentState.status = 'correct';
                    else if (distance <= Math.ceil(graphemeSplitter(refWord).length / 2)) {
                        currentState.status = 'half';
                        session.halfMistakes++;
                    } else {
                        currentState.status = 'wrong';
                        session.fullMistakes++;
                    }
                }
                
                session.currentWordIndex++;
                dom.hiddenInput.value = '';

                if (session.currentWordIndex >= session.allRefWords.length) {
                    endPractice();
                } else {
                    if (session.currentWordIndex >= session.refWords.length - APPEND_WORDS_THRESHOLD) {
                        appendMoreWords();
                    }
                    setTimeout(updateUI, 0); 
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Backspace' && !e.repeat) {
                    appState.session.backspaceCount++;
                    if (dom.hiddenInput.value === '' && appState.session.currentWordIndex > 0) {
                        e.preventDefault();
                        const { session } = appState;
                        session.currentWordIndex--;
                        const prevState = session.wordStates[session.currentWordIndex];
                        if (prevState.status === 'wrong' || (prevState.status === 'omitted' && prevState.typed === '')) session.fullMistakes--;
                        if (prevState.status === 'half') session.halfMistakes--;
                        session.totalKeystrokes -= (graphemeSplitter(prevState.typed || '').length + (prevState.typed ? 1 : 0));
                        prevState.status = 'untyped';
                        dom.hiddenInput.value = prevState.typed || '';
                        updateCurrentWordVisuals(); // Update visuals on backspace to previous word
                        updateUI();
                        return;
                    }
                }
            };

            const handleInput = () => {
                if (!appState.isPracticeActive) {
                     if (dom.hiddenInput.value) { // Auto-start timer on first input
                        appState.isPracticeActive = true;
                        appState.session.startTime = Date.now();
                        startTimer();
                    } else {
                        return;
                    }
                }
                if (appState.session.timeLeft <= 0 && appState.config.duration > 0) return;

                const typedValue = dom.hiddenInput.value;
                if (typedValue.endsWith(' ')) {
                    if(typedValue.trim() !== '' || appState.session.currentWordIndex < appState.session.refWords.length) {
                        commitCurrentWord();
                    }
                    return;
                }
                
                updateCurrentWordVisuals();

                const { session } = appState;
                const refWord = session.refWords[session.currentWordIndex];
                if (autoShiftEnabled && refWord && graphemeSplitter(typedValue).length === graphemeSplitter(refWord).length) {
                    commitCurrentWord();
                } else {
                    updateUI();
                }
            };
            
            const endPractice = () => {
                if (appState.config.level === 'Free Hand') {
                    switchView('setup');
                    return;
                }
                if (appState.timerId) clearInterval(appState.timerId);
                if (!appState.isPracticeActive && appState.timerId == null) return;
                if(dom.hiddenInput.value && appState.session.currentWordIndex < appState.session.refWords.length){
                    commitCurrentWord();
                }
                appState.isPracticeActive = false;
                appState.timerId = null;
                dom.hiddenInput.blur();
                showResults();
            };

            const showResults = () => {
                const timeTakenSec = appState.session.startTime > 0 ? Math.min(appState.config.duration, Math.round((Date.now() - appState.session.startTime) / 1000)) : appState.config.duration;
                const effectiveTime = timeTakenSec > 0 ? timeTakenSec : 1;
                const finalKeystrokes = appState.session.wordStates.slice(0, appState.session.currentWordIndex).reduce((sum, s) => sum + graphemeSplitter(s.typed || '').length + (s.typed ? 1 : 0) , 0);

                const finalMetrics = window.computeTypingMetrics({
                    timeSeconds: effectiveTime,
                    keystrokesOverride: Math.max(0, finalKeystrokes),
                    fullMistakes: appState.session.fullMistakes,
                    halfMistakes: appState.session.halfMistakes,
                });
                
                const isQualified = appState.lang === 'en' ? (finalMetrics.netWPM >= 30) : (finalMetrics.netWPM >= 25);
                dom.newResults.passageTitle.textContent = `${appState.config.level}: ${appState.config.method}`;
                dom.newResults.timeDuration.textContent = (appState.config.duration / 60).toFixed(2);
                dom.newResults.timeTaken.textContent = (effectiveTime / 60).toFixed(2);
                dom.newResults.keystrokes.textContent = finalMetrics.totalKeystrokes;
                dom.newResults.wordsTyped.textContent = appState.session.wordStates.slice(0, appState.session.currentWordIndex).filter(s => s.typed).length;
                dom.newResults.fullMistakes.textContent = appState.session.fullMistakes;
                dom.newResults.halfMistakes.textContent = appState.session.halfMistakes;
                dom.newResults.totalWrongWords.textContent = (appState.session.fullMistakes + appState.session.halfMistakes);
                dom.newResults.accuracy.textContent = finalMetrics.accuracyDisplay;
                dom.newResults.grossSpeed.textContent = finalMetrics.grossWPMDisplay;
                dom.newResults.netSpeed.textContent = finalMetrics.netWPMDisplay;
                dom.newResults.backspaceCount.textContent = appState.session.backspaceCount;
                dom.newResults.resultText.textContent = isQualified ? "Qualified" : "Not Qualified";
                dom.newResults.resultCard.className = isQualified ? 'result-card qualified' : 'result-card not-qualified';
                dom.newResults.formulaNote.innerHTML = `<code>Gross WPM</code> = (Total Keystrokes / 5) / Time (min)<br><code>Error Penalty</code> = Full Mistakes + (Half Mistakes / 2)<br><code>Net WPM</code> = Gross WPM - (Error Penalty / Time(min))<br><code>Accuracy</code> = (Net WPM / Gross WPM) * 100`.trim().replace(/\s{2,}/g, ' ');

                let originalHTML = '', typedHTML = '';
                appState.session.wordStates.slice(0, appState.session.currentWordIndex).forEach(state => {
                    const s = state.ref || '', t = state.typed || '';
                    const statusClass = { 'correct': 'correct-word', 'wrong': 'wrong-word', 'half': 'half-mistake-word', 'omitted': 'omitted-word' }[state.status] || '';
                    if (state.status === 'omitted' || state.status === 'untyped') {
                         originalHTML += `<span class="omitted-word">${s}</span> `;
                         typedHTML += ` `;
                    } else if(statusClass) {
                        originalHTML += `<span class="${statusClass}">${s}</span> `;
                        typedHTML += `<span class="${statusClass}">${t}</span> `;
                    } else {
                         originalHTML += `<span>${s}</span> `;
                         typedHTML += `<span>${t}</span> `;
                    }
                });
                dom.newResults.originalPassage.innerHTML = originalHTML;
                dom.newResults.typedPassage.innerHTML = typedHTML;
                
                updateMistakeHistory();
                renderMistakeAnalysis();
                updatePracticeHistory(finalMetrics);
                renderProgressGraphs();
                if (isQualified) triggerCelebration();
                
                dom.resultsModal.classList.add('active');
            };

            const hideResults = () => { dom.resultsModal.classList.remove('active'); };
            
            // --- New Display Mode Logic ---
            const setMode = (mode, fromUser = false) => {
                document.body.classList.remove('laptop-mode', 'phone-mode');
                document.body.classList.add(`${mode}-mode`);

                dom.mode.laptopBtn.classList.toggle('active', mode === 'laptop');
                dom.mode.phoneBtn.classList.toggle('active', mode === 'phone');
                
                if (mode === 'laptop') {
                    dom.liveTypedDisplay.appendChild(dom.caret);
                } else {
                    dom.textDisplayWrapper.appendChild(dom.caret);
                }

                if (fromUser) {
                    storage.set('typingDisplayMode', mode);
                }
                if (appState.isPracticeActive) {
                    setTimeout(() => updateUI(), 0);
                }
            };
            
            const detectAndSetMode = () => {
                const mode = window.innerWidth >= 768 ? 'laptop' : 'phone';
                setMode(mode);
            };

            // --- INITIALIZATION ---
            const init = () => {
                resetState();
                populateLevels();
                populateMethods();

                dom.levelSelect.addEventListener('change', populateMethods);
                [dom.langEnglishBtn, dom.langHindiBtn].forEach(btn => {
                    btn.addEventListener('click', () => {
                        dom.langEnglishBtn.classList.remove('active');
                        dom.langHindiBtn.classList.remove('active');
                        btn.classList.add('active');
                        appState.lang = btn.dataset.lang;
                    });
                });
                dom.startBtn.addEventListener('click', startPractice);
                dom.submitBtn.addEventListener('click', endPractice);
                dom.hiddenInput.addEventListener('keydown', handleKeyDown);
                dom.hiddenInput.addEventListener('input', handleInput);
                dom.textDisplayWrapper.addEventListener('click', () => dom.hiddenInput.focus());
                
                dom.hiddenInput.addEventListener('blur', () => {
                    if (appState.isPracticeActive) {
                        setTimeout(() => dom.hiddenInput.focus(), 10);
                    }
                });

                window.addEventListener('resize', () => {
                    const savedMode = storage.get('typingDisplayMode');
                    if (!savedMode) detectAndSetMode();
                    if(appState.isPracticeActive) requestAnimationFrame(positionCaretAndScroll);
                });

                dom.resultActions.retry.addEventListener('click', () => {
                    hideResults();
                    const oldConfig = { ...appState.config };
                    resetState();
                    appState.config = oldConfig;
                    appState.lang = dom.langEnglishBtn.classList.contains('active') ? 'en' : 'hi';
                    
                    const allRefWords = tokenize(oldConfig.sourceText);
                    appState.session.allRefWords = allRefWords;
                    appState.session.refWords = allRefWords.slice(0, INITIAL_RENDER_WORDS);
                    appState.session.wordStates = appState.session.refWords.map(ref => ({ ref, typed: '', status: 'untyped' }));
                    appState.session.timeLeft = oldConfig.duration;
                    
                    switchView('practice');
                    renderWords();
                    dom.hiddenInput.focus();
                });
                dom.resultActions.newTest.addEventListener('click', () => {
                    if (appState.config.level === 'Paste Your Text') dom.pasteTextArea.value = '';
                    hideResults();
                    switchView('setup');
                });
                dom.resultActions.backToHome.addEventListener('click', () => {
                    if (appState.config.level === 'Paste Your Text') dom.pasteTextArea.value = '';
                    hideResults();
                    switchView('setup');
                });
                
                // Mode buttons setup
                dom.mode.laptopBtn.addEventListener('click', () => setMode('laptop', true));
                dom.mode.phoneBtn.addEventListener('click', () => setMode('phone', true));
                
                const savedMode = storage.get('typingDisplayMode');
                if (savedMode) {
                    setMode(savedMode);
                } else {
                    detectAndSetMode();
                }

                dom.loadingStatus.textContent = 'Fetching fresh articles... This may take a moment on your first visit.';
                prefetchArticle('en');
                prefetchArticle('hi');
            };

            init();
        });
    </script>

<!-- Unified metrics override script (appends at end). -->
<script>
(function(){
  /**
   * Calculates typing metrics based on government exam formulas.
   * @param {object} options - The options for calculation.
   * @param {number} [options.timeSeconds=1] - The total time elapsed in seconds.
   * @param {number} [options.keystrokesOverride=0] - The total number of characters typed.
   * @param {number} [options.fullMistakes=0] - The count of full-mistake words.
   * @param {number} [options.halfMistakes=0] - The count of half-mistake words.
   * @returns {object} An object containing all calculated typing metrics.
   */
  function unifiedComputeTypingMetrics({timeSeconds = 1, keystrokesOverride = 0, fullMistakes = 0, halfMistakes = 0} = {}) {
    const timeSec = (typeof timeSeconds === 'number' && timeSeconds > 0) ? timeSeconds : 1;
    const minutes = timeSec / 60;
    const totalKeystrokes = Number(keystrokesOverride) || 0;

    // 1. Gross WPM = (Total Characters Typed / 5) / Time (minutes)
    const grossWPM = minutes > 0 ? ((totalKeystrokes / 5) / minutes) : 0;

    // 2. Error Penalty (in words) = Full Mistakes + (Half Mistakes / 2)
    const errorPenaltyWords = fullMistakes + (halfMistakes / 2);

    // 3. Net WPM = Gross WPM - (Error Penalty / Time (minutes))
    // According to many government exam rules, the penalty is subtracted from the total words typed, not the WPM rate. 
    // This is equivalent to subtracting the error rate from the gross rate.
    // Net WPM = Gross WPM - (Total Error Penalty Words / Total Time in Minutes)
    const netWPM = minutes > 0 ? Math.max(0, grossWPM - (errorPenaltyWords / minutes)) : 0;
    
    // 4. Accuracy (%) = (Net WPM / Gross WPM) * 100
    const accuracyPercent = totalKeystrokes === 0 ? 0 : (grossWPM > 0 ? Math.max(0, (netWPM / grossWPM)) * 100 : 100);
    
    return {
      grossWPM,
      netWPM,
      accuracyPercent,
      totalKeystrokes: totalKeystrokes,
      errorPenaltyWords: errorPenaltyWords,
      errorChars: errorPenaltyWords, // kept for backward compatibility
      timeSeconds: timeSec,
      grossWPMDisplay: Math.round(grossWPM),
      netWPMDisplay: Math.round(netWPM),
      accuracyDisplay: accuracyPercent.toFixed(2),
    };
  }

  if (typeof window !== 'undefined') {
      window.computeTypingMetrics = unifiedComputeTypingMetrics;
  }

  console.info('Government exam typing metrics script installed.');

})();
</script>
    <!-- üåç Live Visitor Counter -->
<footer style="margin-top:auto; padding:1rem 0; font-size:0.9rem; color:#ccc; text-align:center; border-top:1px solid #333;">
  üëÅÔ∏è <strong>Live Visitors:</strong>
  <a href="https://hits.sh/examyatri.live/Typing.html/" target="_blank" style="text-decoration:none;">
    <img src="https://hits.sh/examyatri.live/Typing.html.svg?view=today-total&label=Visitors&color=brightgreen&style=for-the-badge"
         alt="Live Visitor Counter"
         style="vertical-align:middle; border-radius:6px; margin-left:5px;">
  </a>
</footer>

</body>
</html>