<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ExamYatri Typing - Real Exam Simulator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --primary-color: #4CAF50; /* Green for accents */
            --error-color: #F44336;
            --caret-color: #2196F3;
            --disabled-color: #555555;
            --border-color: #333333;
            --font-family: 'Roboto Mono', monospace;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            text-align: center;
        }

        .container {
            width: 90%;
            max-width: 900px;
            margin: 0 auto;
            padding: 1rem 0;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 500;
        }

        .language-switch {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .lang-btn {
            background: transparent;
            color: var(--text-color);
            border: none;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-family: var(--font-family);
            transition: background-color 0.2s;
        }

        .lang-btn.active {
            background-color: var(--primary-color);
        }

        /* Views */
        .view {
            display: none;
            flex-direction: column;
            flex-grow: 1;
        }
        .view.active {
            display: flex;
        }

        /* Setup View */
        #setup-view {
            justify-content: center;
            gap: 1.5rem;
        }

        .setup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .setup-card {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .setup-card label {
            text-align: left;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        .custom-select {
            width: 100%;
            padding: 0.75rem;
            background-color: #111;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: var(--font-family);
            font-size: 1rem;
            cursor: pointer;
        }

        .minus-marking-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
        }
        .minus-marking-controls > div {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .minus-marking-controls input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .minus-marking-controls input[type="number"] {
            width: 60px;
            padding: 0.5rem;
            background-color: #111;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: var(--font-family);
        }

        #start-practice-btn {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            padding: 1rem;
            background-color: var(--primary-color);
            color: #000;
            font-weight: 700;
            border: none;
            border-radius: 6px;
            font-size: 1.2rem;
            font-family: var(--font-family);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        #start-practice-btn:disabled {
            background-color: var(--disabled-color);
            cursor: not-allowed;
        }

        #loading-status {
            min-height: 1.2em;
            margin-bottom: 1rem;
        }
        
        /* Practice View */
        #practice-view {
            gap: 1rem;
        }

        .stats-dashboard {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
        }

        .stat-item {
            display: flex;
            gap: 0.5rem;
            align-items: baseline;
        }
        .stat-item .label {
            font-size: 0.8rem;
            color: #aaa;
        }
        .stat-item .value {
            font-size: 1.2rem;
            font-weight: 700;
        }

        #text-display-wrapper {
            border: 1px solid var(--border-color);
            padding: 1rem;
            border-radius: 6px;
            font-size: 1.5rem;
            line-height: 1.8;
            text-align: left;
            overflow-y: auto;
            scroll-behavior: smooth;
            height: 250px;
            position: relative;
            flex-shrink: 0;
            user-select: none;
            cursor: text;
        }
        
        #text-display {
            color: #888;
            position: relative;
            overflow-wrap: break-word; /* Prevents text from overflowing horizontally */
        }
        #text-display.hindi {
            font-family: 'Noto Sans Devanagari', serif;
        }

        .char {
            display: inline;
        }
        .char.correct { color: var(--primary-color); }
        .char.incorrect { color: var(--error-color); text-decoration: underline; }
        
        .caret {
            position: absolute;
            width: 2px;
            background-color: var(--caret-color);
            animation: blink 1s infinite;
            transition: left 0.1s linear, top 0.1s linear;
            border-radius: 1px;
            height: calc(1.5rem * 1.2);
            margin-top: calc(1.5rem * 0.2);
        }
        @keyframes blink { 50% { opacity: 0; } }

        #hidden-input {
            position: fixed;
            left: 0;
            top: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            margin: -1px;
            padding: 0;
            border: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
        }

        #free-hand-area {
            width: 100%;
            height: 100%;
            background: #111;
            color: var(--text-color);
            border: none;
            font-size: 1.2rem;
            font-family: inherit;
            resize: none;
            padding: 1rem;
        }

        #submit-test-btn {
            padding: 0.75rem 2rem;
            background-color: var(--error-color);
            color: var(--text-color);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 0 auto;
        }
        
        /* New Results Modal */
        #results-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
            padding: 1rem;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #results-modal.active {
            display: flex;
        }

        .results-content {
            background-color: #2a2a2e;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            width: 100%;
            max-width: 850px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            color: #e0e0e0;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
        }
        
        .result-card {
            background-color: #333338;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid #444;
            text-align: left;
        }

        .result-card .title {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 0.5rem;
        }

        .result-card .value {
            font-size: 1.75rem;
            font-weight: 700;
            color: #fff;
        }
         .result-card.qualified .value {
            color: var(--primary-color);
        }
         .result-card.not-qualified .value {
            color: var(--error-color);
        }

        .results-formula-note {
            background-color: #333338;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            text-align: left;
            color: #c0c0c0;
            white-space: pre-wrap;
        }
        .results-formula-note code {
            color: #fff;
            font-weight: bold;
        }
        .results-comparison {
            text-align: left;
        }
        .comparison-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .comparison-passages {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            height: 150px;
        }

        .passage-display {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            font-family: inherit;
            overflow-y: auto;
            text-align: left;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .passage-display span {
            border-radius: 2px;
            padding: 1px 0;
        }

        .correct-word {
            color: var(--primary-color);
        }
        .wrong-word {
            color: var(--error-color);
            background-color: rgba(244, 67, 54, 0.2);
            text-decoration: line-through;
        }
        .half-mistake-word {
            color: #FFA500; /* Orange */
            background-color: rgba(255, 165, 0, 0.2);
            text-decoration: underline;
            text-decoration-style: wavy;
        }
        .omitted-word {
            background-color: rgba(244, 67, 54, 0.3);
            border-radius: 3px;
            padding: 0 2px;
        }


        .results-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            border-top: 1px solid var(--border-color);
            padding-top: 1.5rem;
            position: sticky;
            bottom: -1.5rem;
            background-color: #2a2a2e;
            margin-left: -1.5rem;
            margin-right: -1.5rem;
            padding-left: 1.5rem;
            padding-right: 1.5rem;
            padding-bottom: 1.5rem;
        }

        .results-actions button {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: #222;
            color: var(--text-color);
            font-family: var(--font-family);
            cursor: pointer;
        }

        /* New styles for analytics */
        #mistakes-analysis ul, #improvement-tips ul {
            list-style: none;
            padding-left: 0;
            margin-top: 0.5rem;
        }
        #mistakes-analysis li, #improvement-tips li {
            margin-bottom: 0.5rem;
        }
        #improvement-tips li {
            padding-left: 1.5rem;
            position: relative;
        }
        #improvement-tips li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 2px;
        }

        .mistake-word {
            color: var(--error-color);
            font-weight: bold;
        }
        .suggestion-word {
            color: var(--primary-color);
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-top: 1rem;
        }

        /* Rules Modal */
        #rules-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            z-index: 1001; /* Above results modal */
            animation: fadeIn 0.3s ease;
            padding: 1rem;
        }
        #rules-modal.active {
            display: flex;
        }
        .rules-content {
            background-color: #2a2a2e;
            padding: 2rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            width: 100%;
            max-width: 800px;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
            color: #e0e0e0;
            text-align: left;
            position: relative;
        }
        .rules-content h2, .rules-content h3 {
            color: var(--primary-color);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        .rules-content h2:first-child {
            margin-top: 0;
        }
        .rules-content h4 {
            color: #ccc;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        .rules-content p, .rules-content ul, .rules-content ol {
            margin-bottom: 1rem;
            line-height: 1.7;
        }
        .rules-content ul, .rules-content ol {
            padding-left: 2rem;
        }
        .rules-content li {
            margin-bottom: 0.5rem;
        }
        .rules-content code {
            background-color: #1e1e1e;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: var(--font-family);
            color: #f0f0f0;
        }
        .rules-content .close-btn {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2rem;
            font-weight: bold;
            color: #aaa;
            background: none;
            border: none;
            cursor: pointer;
            line-height: 1;
        }
        .rules-content .close-btn:hover {
            color: #fff;
        }

        .learn-more-link {
            display: block;
            text-align: center;
            margin-top: 1rem;
            color: var(--primary-color);
            cursor: pointer;
            text-decoration: underline;
            font-size: 0.9rem;
        }
        .learn-more-link:hover {
            color: #66bb6a;
        }
        
        @media (min-width: 768px) {
             .charts-container {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .results-grid { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            .result-card .value { font-size: 1.5rem; }
            .comparison-passages { grid-template-columns: 1fr; height: 250px; }
        }

        @media (max-width: 600px) {
            header h1 { font-size: 1.2rem; }
            .setup-grid { grid-template-columns: 1fr; }
            #text-display-wrapper { font-size: 1.2rem; height: 200px; }
            .stat-item .value { font-size: 1rem; }
            .results-header { flex-direction: column; align-items: flex-start; gap: 0.5rem; }
            .results-content { padding: 1rem; }
            .rules-content { padding: 1.5rem 1rem; }
            .rules-content .close-btn { top: 0.5rem; right: 1rem; }
            .results-actions {
                bottom: -1rem;
                margin-left: -1rem;
                margin-right: -1rem;
                padding-left: 1rem;
                padding-right: 1rem;
                padding-bottom: 1rem;
            }
            .results-grid { 
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }
            .result-card {
                padding: 0.5rem;
            }
            .result-card .title {
                font-size: 0.7rem;
            }
            .result-card .value {
                font-size: 1.1rem;
                word-break: break-all;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="container header-content">
            <h1>ExamYatri Typing</h1>
            <div class="language-switch">
                <button id="lang-english-btn" class="lang-btn active" data-lang="en">English</button>
                <button id="lang-hindi-btn" class="lang-btn" data-lang="hi">‡§π‡§ø‡§Ç‡§¶‡•Ä</button>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- Setup View -->
        <section id="setup-view" class="view active">
            <div class="setup-grid">
                <div class="setup-card">
                    <label for="level-select">1. Difficulty Level</label>
                    <select id="level-select" class="custom-select"></select>
                </div>
                <div class="setup-card">
                    <label for="method-select">2. Practice Method</label>
                    <select id="method-select" class="custom-select"></select>
                </div>
                <div class="setup-card">
                    <label for="duration-select">3. Duration</label>
                    <select id="duration-select" class="custom-select">
                        <option value="1">1 Minute</option>
                        <option value="2">2 Minutes</option>
                        <option value="5" selected>5 Minutes</option>
                        <option value="10">10 Minutes</option>
                        <option value="15">15 Minutes</option>
                        <option value="30">30 Minutes</option>
                    </select>
                </div>
                <div class="setup-card minus-marking-controls">
                    <label>4. Minus Marking</label>
                    <div>
                        <input type="checkbox" id="minus-marking-enabled">
                        <label for="minus-marking-enabled">Enable</label>
                    </div>
                    <div>
                        <input type="number" id="minus-marking-value" min="0" max="5" value="1" disabled>
                        <label for="minus-marking-value">WPM per error</label>
                    </div>
                </div>
            </div>
            <div id="paste-text-container" style="display: none; width: 100%; margin-bottom: 1rem;">
                <label for="paste-text-area" style="text-align: left; font-size: 0.9rem; color: #ccc; margin-bottom: 0.5rem; display: block;">Paste your text below:</label>
                <textarea id="paste-text-area" style="width: 100%; height: 150px; background: #111; color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; font-family: inherit; font-size: 1rem; padding: 0.75rem; resize: vertical;"></textarea>
            </div>
            <p id="loading-status"></p>
            <button id="start-practice-btn">Start Practice</button>
        </section>

        <!-- Practice View -->
        <section id="practice-view" class="view">
            <div class="stats-dashboard">
                <div class="stat-item"><span class="label">Time:</span><span id="stat-time" class="value">00:00</span></div>
                <div class="stat-item"><span class="label">Gross WPM:</span><span id="stat-gross-wpm" class="value">0</span></div>
                <div class="stat-item"><span class="label">Net WPM:</span><span id="stat-net-wpm" class="value">0</span></div>
                <div class="stat-item"><span class="label">Errors:</span><span id="stat-errors" class="value">0</span></div>
                <div class="stat-item"><span class="label">Accuracy:</span><span id="stat-accuracy" class="value">100%</span></div>
            </div>
            <div id="text-display-wrapper">
                <div id="text-display"></div>
                <div id="caret" class="caret" style="display: none;"></div>
                <textarea id="free-hand-area" style="display: none;" placeholder="Start typing..."></textarea>
            </div>
            <button id="submit-test-btn">Submit Now</button>
        </section>
    </main>

    <!-- New Results Modal -->
    <div id="results-modal">
        <div class="results-content">
            <div class="results-header">
                <div><strong>Passage Title:</strong> <span id="res-passage-title">N/A</span></div>
                <div><strong>Time Duration:</strong> <span id="res-time-duration">00:00</span> min.</div>
                <div><strong>Time Taken:</strong> <span id="res-time-taken">00:00</span> min.</div>
            </div>
            <div class="results-grid">
                <div class="result-card">
                    <div class="title">Total Keystrokes / Words Typed</div>
                    <div class="value"><span id="res-keystrokes">0</span> / <span id="res-words-typed">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Full Mistake (Words)</div>
                    <div class="value"><span id="res-full-mistakes">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Half Mistake (Words)</div>
                    <div class="value"><span id="res-half-mistakes">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Total Wrong Words</div>
                    <div class="value"><span id="res-total-wrong-words">0</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Accuracy</div>
                    <div class="value"><span id="res-accuracy">0.00</span>%</div>
                </div>
                <div class="result-card">
                    <div class="title">Gross Typing Speed (wpm)</div>
                    <div class="value"><span id="res-gross-speed">0.00</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Net Typing Speed (wpm)</div>
                    <div class="value"><span id="res-net-speed">0.00</span></div>
                </div>
                <div class="result-card">
                    <div class="title">Backspace Count</div>
                    <div class="value"><span id="res-backspace-count">0</span></div>
                </div>
                <div id="res-result-card" class="result-card">
                    <div class="title">Result</div>
                    <div class="value"><span id="res-result-text">N/A</span></div>
                </div>
            </div>
            <div class="results-formula-note">
                <span id="res-formula-note">Calculation of Net Speed = (Total Keystrokes / 5) / Time in Minutes.</span>
            </div>
            <a id="learn-more-btn" class="learn-more-link">Learn how mistakes are calculated...</a>
             <div id="res-keystroke-warning" style="color: var(--error-color); text-align: center; font-size: 0.9rem; margin-top: 1rem;"></div>
            
             <div id="practice-duration-summary" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Practice Duration Summary</div>
                <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 1rem; font-size: 0.9rem; color: #e0e0e0; padding-top: 0.5rem;">
                    <div>Today's Practice: <strong id="res-today-practice-time" style="color: #fff; font-weight: bold;">0m 0s</strong></div>
                    <div>Total on Device: <strong id="res-total-practice-time" style="color: #fff; font-weight: bold;">0h 0m 0s</strong></div>
                </div>
            </div>
            
            <!-- New Analytics Sections -->
            <div id="performance-review-section" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Performance Review</div>
                <div id="performance-feedback" class="value" style="font-size: 1rem; white-space: pre-wrap; color: #e0e0e0; line-height: 1.5;"></div>
            </div>

            <div id="weakness-analysis-section" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Common Mistakes & Weak Areas</div>
                <div id="mistakes-analysis" style="font-size: 0.9rem; color: #e0e0e0;"></div>
            </div>
            
            <div id="improvement-tips-section" class="result-card" style="text-align: left; display: none; background-color: #333338;">
                <div class="title">Tips for Improvement</div>
                <div id="improvement-tips" style="font-size: 0.9rem; color: #e0e0e0;"></div>
            </div>

            <div id="progress-graphs-section" style="display: none;">
                <h3 style="text-align: left; margin: 1rem 0 0.5rem; color: #e0e0e0;">Your Progress</h3>
                <div class="charts-container">
                    <canvas id="speed-chart"></canvas>
                    <canvas id="accuracy-chart"></canvas>
                </div>
            </div>

            <div class="results-comparison">
                <div class="comparison-toggle">
                    <label for="comparison-switch">Detailed Comparison</label>
                    <input type="checkbox" id="comparison-switch" checked>
                </div>
                <div class="comparison-passages">
                    <div id="res-original-passage" class="passage-display" aria-readonly="true" role="textbox" aria-label="Original Passage"></div>
                    <div id="res-typed-passage" class="passage-display" aria-readonly="true" role="textbox" aria-label="Typed Passage"></div>
                </div>
            </div>
            <div class="results-actions">
                <button id="retry-test-btn">Retry Same Test</button>
                <button id="new-test-btn">Next Practice Text</button>
                <button id="back-to-home-btn">Back to Home</button>
            </div>
        </div>
    </div>
    
    <!-- Rules Modal -->
    <div id="rules-modal">
        <div class="rules-content">
            <button id="close-rules-btn" class="close-btn">&times;</button>
            <h2>Understanding Typing Mistakes & Scoring</h2>
            
            <h3>1. What is a Full Word Mistake?</h3>
            <p>A full-word mistake means the entire word is incorrect, missing, extra, or completely misplaced in the sentence. The examiner or software will not count it as correct even if one letter is missing or added in such a way that the meaning or spelling changes completely.</p>
            <p><strong>Examples:</strong></p>
            <ul>
                <li>Original text: <code>‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§æ‡§∞ ‡§®‡•á ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡•Ä‡•§</code><br>Typed text: <code>‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§∞ ‡§®‡•á ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡•Ä‡•§</code><br>Here, the word ‚Äú‡§∏‡§∞‡§ï‡§æ‡§∞‚Äù is typed as ‚Äú‡§∏‡§∞‡§ï‡§∞‚Äù. The whole word meaning changes, so it is counted as one full-word mistake.</li>
                <li>Original text: <code>‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§æ‡§∞ ‡§®‡•á ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡•Ä‡•§</code><br>Typed text: <code>‡§≠‡§æ‡§∞‡§§ ‡§®‡•á ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡•Ä‡•§</code><br>The word ‚Äú‡§∏‡§∞‡§ï‡§æ‡§∞‚Äù is completely missing. This is also one full-word mistake.</li>
                <li>Original text: <code>‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§æ‡§∞ ‡§®‡•á ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡•Ä‡•§</code><br>Typed text: <code>‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§æ‡§∞ ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡•Ä‡•§</code><br>The word ‚Äú‡§®‡•á‚Äù is missing, so again one full-word mistake.</li>
            </ul>
            <p>In short, whenever a complete word is either missing, added extra, or spelled so wrongly that it loses its correct identity ‚Äî it is a full-word mistake.</p>
            
            <hr style="border-color: var(--border-color); margin: 1.5rem 0;">

            <h3>‚úèÔ∏è 2. What is a Half Word Mistake?</h3>
            <p>A half-word mistake means that only a small part of the word is incorrect ‚Äî for example, one letter is extra, missing, or slightly misplaced ‚Äî but the word is still understandable.</p>
            <p><strong>Examples:</strong></p>
            <ul>
                <li>Original: <code>‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§æ‡§∞</code><br>Typed: <code>‡§≠‡§æ‡§∞‡§§‡§æ ‡§∏‡§∞‡§ï‡§æ‡§∞</code><br>One extra letter ‚Äú‡§æ‚Äù added at the end of ‚Äú‡§≠‡§æ‡§∞‡§§‚Äù. It still looks like ‚Äú‡§≠‡§æ‡§∞‡§§‚Äù, so it‚Äôs a half-word mistake.</li>
                <li>Original: <code>‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§æ‡§∞</code><br>Typed: <code>‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§æ</code><br>The last letter ‚Äú‡§∞‚Äù of ‚Äú‡§∏‡§∞‡§ï‡§æ‡§∞‚Äù is missing. The word is almost correct, so again half-word mistake.</li>
                <li>Original: <code>‡§µ‡§ø‡§¶‡•ç‡§Ø‡§æ‡§≤‡§Ø</code><br>Typed: <code>‡§µ‡§ø‡§ß‡§æ‡§≤‡§Ø</code><br>One character missing in between but readable ‚Üí half-word mistake.</li>
            </ul>
            <p>üëâ In general typing exams, two half-word mistakes = one full-word mistake.</p>

            <hr style="border-color: var(--border-color); margin: 1.5rem 0;">

            <h3>‚öôÔ∏è 3. How Mistakes Affect WPM (Words Per Minute)</h3>
            <p>Typing speed is calculated in two parts ‚Äî Gross speed and Net speed.</p>
            <ol>
                <li><strong>Gross WPM</strong> means your total speed without considering mistakes.<br>Formula: <code>Gross WPM = (Total characters typed √∑ 5) √∑ Time in minutes</code></li>
                <li><strong>Error penalty</strong> depends on the number of full and half mistakes.<br>Formula: <code>Error Penalty = (Full-word mistakes + Half-word mistakes √∑ 2)</code></li>
                <li><strong>Net WPM</strong> means your final correct speed after deducting the penalty.<br>Formula: <code>Net WPM = Gross WPM ‚àí Error Penalty</code></li>
            </ol>

            <hr style="border-color: var(--border-color); margin: 1.5rem 0;">

            <h3>üìò 4. Calculation Examples</h3>
            <h4>Example 1 ‚Äì With Few Mistakes</h4>
            <p>Suppose you typed 2500 characters in 10 minutes.<br>
            Gross WPM = 2500 √∑ 5 √∑ 10 = 50 WPM<br>
            You made:<br>
            &nbsp;&nbsp;‚Ä¢ 4 full-word mistakes<br>
            &nbsp;&nbsp;‚Ä¢ 2 half-word mistakes = 1 full mistake<br>
            Total = 5 full-word mistakes.<br>
            Net WPM = 50 ‚àí 5 = 45 WPM<br>
            Your accuracy = (Net √∑ Gross) √ó 100 = (45 √∑ 50) √ó 100 = 90%</p>

            <h4>Example 2 ‚Äì With More Mistakes</h4>
            <p>You typed 2000 characters in 10 minutes.<br>
            Gross WPM = 2000 √∑ 5 √∑ 10 = 40 WPM<br>
            Mistakes:<br>
            6 full-word mistakes + 4 half-word mistakes = 6 + 2 = 8 full mistakes<br>
            Net WPM = 40 ‚àí 8 = 32 WPM<br>
            Accuracy = (32 √∑ 40) √ó 100 = 80%</p>
            
            <hr style="border-color: var(--border-color); margin: 1.5rem 0;">

            <h3>üß† 5. Important Notes for Exams</h3>
            <ul>
                <li>If you type extra words not present in the passage ‚Üí full-word mistake.</li>
                <li>If you skip a word ‚Üí full-word mistake.</li>
                <li>If spacing is missing between two words (e.g., ‚Äú‡§≠‡§æ‡§∞‡§§‡§∏‡§∞‡§ï‡§æ‡§∞‚Äù) ‚Üí half-word mistake, but if it creates confusion ‚Üí full-word mistake.</li>
                <li>Punctuation errors (like missing full stop or comma) ‚Üí usually half mistake, unless exam rules say otherwise.</li>
                <li>Always check exam instructions, because some boards (like CPCT) have slightly different marking patterns.</li>
            </ul>
            
            <hr style="border-color: var(--border-color); margin: 1.5rem 0;">

            <h3>üí° 6. Summary in Simple Words</h3>
            <ul>
                <li>Full-word mistake = Entire word wrong / missing / added</li>
                <li>Half-word mistake = Minor spelling or letter issue</li>
                <li>2 half mistakes = 1 full mistake</li>
                <li>Net WPM = Gross WPM ‚àí Total full mistakes</li>
                <li>Accuracy (%) = (Net √∑ Gross) √ó 100</li>
            </ul>
        </div>
    </div>


    <textarea id="hidden-input" autofocus autocapitalize="none" autocorrect="off"></textarea>
    
    <footer style="margin-top: auto; padding: 1rem 0; font-size: 0.9rem; color: #888; border-top: 1px solid var(--border-color);">
        Visitor Count: <span id="visitCount">0</span>
    </footer>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const dom = {
                setupView: document.getElementById('setup-view'),
                practiceView: document.getElementById('practice-view'),
                levelSelect: document.getElementById('level-select'),
                methodSelect: document.getElementById('method-select'),
                durationSelect: document.getElementById('duration-select'),
                minusMarkingEnabled: document.getElementById('minus-marking-enabled'),
                minusMarkingValue: document.getElementById('minus-marking-value'),
                loadingStatus: document.getElementById('loading-status'),
                startBtn: document.getElementById('start-practice-btn'),
                pasteTextContainer: document.getElementById('paste-text-container'),
                pasteTextArea: document.getElementById('paste-text-area'),

                stats: {
                    time: document.getElementById('stat-time'),
                    grossWpm: document.getElementById('stat-gross-wpm'),
                    netWpm: document.getElementById('stat-net-wpm'),
                    errors: document.getElementById('stat-errors'),
                    accuracy: document.getElementById('stat-accuracy'),
                },
                textDisplayWrapper: document.getElementById('text-display-wrapper'),
                textDisplay: document.getElementById('text-display'),
                caret: document.getElementById('caret'),
                hiddenInput: document.getElementById('hidden-input'),
                freeHandArea: document.getElementById('free-hand-area'),
                submitBtn: document.getElementById('submit-test-btn'),

                resultsModal: document.getElementById('results-modal'),
                newResults: {
                    passageTitle: document.getElementById('res-passage-title'),
                    timeDuration: document.getElementById('res-time-duration'),
                    timeTaken: document.getElementById('res-time-taken'),
                    keystrokes: document.getElementById('res-keystrokes'),
                    wordsTyped: document.getElementById('res-words-typed'),
                    fullMistakes: document.getElementById('res-full-mistakes'),
                    halfMistakes: document.getElementById('res-half-mistakes'),
                    totalWrongWords: document.getElementById('res-total-wrong-words'),
                    accuracy: document.getElementById('res-accuracy'),
                    grossSpeed: document.getElementById('res-gross-speed'),
                    netSpeed: document.getElementById('res-net-speed'),
                    backspaceCount: document.getElementById('res-backspace-count'),
                    resultCard: document.getElementById('res-result-card'),
                    resultText: document.getElementById('res-result-text'),
                    formulaNote: document.getElementById('res-formula-note'),
                    keystrokeWarning: document.getElementById('res-keystroke-warning'),
                    originalPassage: document.getElementById('res-original-passage'),
                    typedPassage: document.getElementById('res-typed-passage'),
                },
                resultActions: {
                    retry: document.getElementById('retry-test-btn'),
                    newTest: document.getElementById('new-test-btn'),
                    backToHome: document.getElementById('back-to-home-btn'),
                },
                langEnglishBtn: document.getElementById('lang-english-btn'),
                langHindiBtn: document.getElementById('lang-hindi-btn'),
                // New analytics elements
                practiceDurationSummary: document.getElementById('practice-duration-summary'),
                resTodayPracticeTime: document.getElementById('res-today-practice-time'),
                resTotalPracticeTime: document.getElementById('res-total-practice-time'),
                performanceReviewSection: document.getElementById('performance-review-section'),
                performanceFeedback: document.getElementById('performance-feedback'),
                weaknessAnalysisSection: document.getElementById('weakness-analysis-section'),
                mistakesAnalysis: document.getElementById('mistakes-analysis'),
                improvementTipsSection: document.getElementById('improvement-tips-section'),
                improvementTips: document.getElementById('improvement-tips'),
                progressGraphsSection: document.getElementById('progress-graphs-section'),
                speedChartCanvas: document.getElementById('speed-chart'),
                accuracyChartCanvas: document.getElementById('accuracy-chart'),
                // Rules modal elements
                rulesModal: document.getElementById('rules-modal'),
                closeRulesBtn: document.getElementById('close-rules-btn'),
                learnMoreBtn: document.getElementById('learn-more-btn'),
            };

            const GRAPHEME_SPLITTER = new Intl.Segmenter();
            const splitTextToChars = (text) => [...GRAPHEME_SPLITTER.segment(text)].map(s => s.segment);
            
            const KEYS = {
                en: { home: "asdfjkl;", top: "qwertyuiop", bottom: "zxcvbnm,.", numbers: "1234567890", symbols: "!@#$%^&*()_+-=[]{}|;':\",./<>?" },
                hi: { home: "‡•ã‡•á‡§ø‡•ç‡§ï‡§∏‡§π‡§Æ‡§§‡§∞‡§≤", top: "‡•å‡•à‡§æ‡•Ä‡§™‡•É‡§õ‡§†‡§ü‡§ù‡§´", bottom: "‡§º‡§ã‡§¶‡§ú‡§ó‡§¨‡§Ö‡§°‡§º‡§ß", numbers: "‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø‡•¶", symbols: "‡•§(),'\"-:", }
            };
             const OFFLINE_FALLBACK = {
                en: [ "The quick brown fox jumps over the lazy dog.", "Technology has changed the way we live and work.", "The internet connects people from all over the world.", "Reading books is a great way to expand your knowledge.", "Success is not final, failure is not fatal: it is the courage to continue that counts.", "The only way to do great work is to love what you do.", "Believe you can and you're halfway there.", "The future belongs to those who believe in the beauty of their dreams.", "Strive not to be a success, but rather to be of value.", "In the middle of every difficulty lies opportunity.", ],
                hi: [ "‡§∏‡•Ç‡§∞‡§ú ‡§ï‡•Ä ‡§™‡§π‡§≤‡•Ä ‡§ï‡§ø‡§∞‡§£ ‡§Ü‡§∂‡§æ ‡§≤‡•á‡§ï‡§∞ ‡§Ü‡§§‡•Ä ‡§π‡•à‡•§", "‡§∏‡§ö‡•ç‡§ö‡§æ ‡§Æ‡§ø‡§§‡•ç‡§∞ ‡§µ‡§π‡•Ä ‡§π‡•à ‡§ú‡•ã ‡§ï‡§†‡§ø‡§® ‡§∏‡§Æ‡§Ø ‡§Æ‡•á‡§Ç ‡§∏‡§æ‡§• ‡§¶‡•á‡•§", "‡§™‡§∞‡§ø‡§∂‡•ç‡§∞‡§Æ ‡§π‡•Ä ‡§∏‡§´‡§≤‡§§‡§æ ‡§ï‡•Ä ‡§ï‡•Å‡§Ç‡§ú‡•Ä ‡§π‡•à‡•§", "‡§ú‡•ç‡§û‡§æ‡§® ‡§∏‡§¨‡§∏‡•á ‡§¨‡•ú‡•Ä ‡§∂‡§ï‡•ç‡§§‡§ø ‡§π‡•à‡•§", "‡§è‡§ï ‡§π‡§ú‡§æ‡§∞ ‡§Æ‡•Ä‡§≤ ‡§ï‡•Ä ‡§Ø‡§æ‡§§‡•ç‡§∞‡§æ ‡§è‡§ï ‡§ï‡§¶‡§Æ ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã‡§§‡•Ä ‡§π‡•à‡•§", "‡§∏‡§Æ‡§Ø ‡§ï‡§ø‡§∏‡•Ä ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§æ‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ‡•§", "‡§∏‡•ç‡§µ‡§∏‡•ç‡§• ‡§∂‡§∞‡•Ä‡§∞ ‡§Æ‡•á‡§Ç ‡§π‡•Ä ‡§∏‡•ç‡§µ‡§∏‡•ç‡§• ‡§Æ‡§® ‡§ï‡§æ ‡§µ‡§æ‡§∏ ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§", "‡§ï‡§ø‡§§‡§æ‡§¨‡•á‡§Ç ‡§π‡§Æ‡§æ‡§∞‡•Ä ‡§∏‡§¨‡§∏‡•á ‡§Ö‡§ö‡•ç‡§õ‡•Ä ‡§¶‡•ã‡§∏‡•ç‡§§ ‡§π‡•ã‡§§‡•Ä ‡§π‡•à‡§Ç‡•§", "‡§ú‡•Ä‡§µ‡§® ‡§è‡§ï ‡§Ö‡§®‡§Æ‡•ã‡§≤ ‡§â‡§™‡§π‡§æ‡§∞ ‡§π‡•à, ‡§á‡§∏‡•á ‡§µ‡•ç‡§Ø‡§∞‡•ç‡§• ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§", "‡§ß‡•à‡§∞‡•ç‡§Ø ‡§î‡§∞ ‡§≤‡§ó‡§® ‡§∏‡•á ‡§π‡§∞ ‡§Æ‡•Å‡§∂‡•ç‡§ï‡§ø‡§≤ ‡§Ü‡§∏‡§æ‡§® ‡§π‡•ã ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à‡•§", ]
            };
             const STATIC_TEXTS = {
                en: { application: "To,\nThe Hiring Manager,\n[Company Name],\n[Company Address]\n\nSubject: Application for the post of [Job Title]\n\nDear Sir/Madam,\nI am writing to express my keen interest in the [Job Title] position advertised on [Platform]. With my skills and experience, I am confident that I would be a valuable asset to your team. My resume is attached for your review. I look forward to hearing from you soon.\n\nSincerely,\n[Your Name]", legal: "Notwithstanding any other provision of this agreement, the parties agree that neither party shall be liable to the other for any indirect, special, or consequential damages. The validity, interpretation, and performance of this agreement shall be governed by and construed in accordance with the laws of the specified jurisdiction, without regard to its conflict of law principles.", letter: "Dear [Recipient Name],\nI hope this letter finds you well. I am writing to you today to discuss the upcoming project deadline. We need to ensure all deliverables are submitted by the end of the week. Please coordinate with your respective teams to finalize the reports. Your prompt attention to this matter is highly appreciated.\n\nBest regards,\n[Your Name]", punctuation: "Wait, what? He asked, \"Are you sure?\" I'm not sure... let's check the guide (page 5). The options are: red, green, or blue; however, I prefer the first one. It's a 'win-win' situation, isn't it?", capitalization: "The United Nations (UN) headquarters is in New York City. Dr. Smith and his colleague, Professor Jones, attended a conference in Paris, France, last Monday. They discussed the impact of climate change on the Arctic Circle.", symbols: "The formula E=mc^2 is famous. Contact me at user@example.com or call +1 (555) 123-4567. The stock price rose by 15% to $1,234.56. We need to check the file at C:\\Users\\Default\\.", },
                hi: { application: "‡§∏‡•á‡§µ‡§æ ‡§Æ‡•á‡§Ç,\n‡§∂‡•ç‡§∞‡•Ä‡§Æ‡§æ‡§® ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§ï,\n[‡§ï‡§Ç‡§™‡§®‡•Ä ‡§ï‡§æ ‡§®‡§æ‡§Æ],\n[‡§ï‡§Ç‡§™‡§®‡•Ä ‡§ï‡§æ ‡§™‡§§‡§æ]\n\n‡§µ‡§ø‡§∑‡§Ø: [‡§™‡§¶ ‡§ï‡§æ ‡§®‡§æ‡§Æ] ‡§™‡§¶ ‡§π‡•á‡§§‡•Å ‡§Ü‡§µ‡•á‡§¶‡§® ‡§™‡§§‡•ç‡§∞\n\n‡§Æ‡§π‡•ã‡§¶‡§Ø,\n‡§∏‡§µ‡§ø‡§®‡§Ø ‡§®‡§ø‡§µ‡•á‡§¶‡§® ‡§π‡•à ‡§ï‡§ø ‡§Æ‡•Å‡§ù‡•á [‡§™‡•ç‡§≤‡•á‡§ü‡§´‡•â‡§∞‡•ç‡§Æ] ‡§™‡§∞ ‡§µ‡§ø‡§ú‡•ç‡§û‡§æ‡§™‡§ø‡§§ [‡§™‡§¶ ‡§ï‡§æ ‡§®‡§æ‡§Æ] ‡§™‡§¶ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡§Ç‡§™‡§®‡•Ä ‡§Æ‡•á‡§Ç ‡§∞‡•Å‡§ö‡§ø ‡§π‡•à‡•§ ‡§Æ‡•á‡§∞‡•á ‡§ï‡•å‡§∂‡§≤ ‡§î‡§∞ ‡§Ö‡§®‡•Å‡§≠‡§µ ‡§ï‡•á ‡§∏‡§æ‡§•, ‡§Æ‡•Å‡§ù‡•á ‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏ ‡§π‡•à ‡§ï‡§ø ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§ü‡•Ä‡§Æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø‡§µ‡§æ‡§® ‡§∏‡§Ç‡§™‡§§‡•ç‡§§‡§ø ‡§π‡•ã‡§ä‡§Ç‡§ó‡§æ‡•§ ‡§Æ‡•á‡§∞‡§æ ‡§¨‡§æ‡§Ø‡•ã‡§°‡§æ‡§ü‡§æ ‡§Ü‡§™‡§ï‡•á ‡§Ö‡§µ‡§≤‡•ã‡§ï‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡§Ç‡§≤‡§ó‡•ç‡§® ‡§π‡•à‡•§ ‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§∏‡•á ‡§∂‡•Ä‡§ò‡•ç‡§∞ ‡§â‡§§‡•ç‡§§‡§∞ ‡§ï‡•Ä ‡§Ü‡§∂‡§æ ‡§π‡•à‡•§\n\n‡§≠‡§µ‡§¶‡•Ä‡§Ø,\n[‡§Ü‡§™‡§ï‡§æ ‡§®‡§æ‡§Æ]", legal: "‡§á‡§∏ ‡§∏‡§Æ‡§ù‡•å‡§§‡•á ‡§ï‡•á ‡§ï‡§ø‡§∏‡•Ä ‡§Ö‡§®‡•ç‡§Ø ‡§™‡•ç‡§∞‡§æ‡§µ‡§ß‡§æ‡§® ‡§ï‡•á ‡§π‡•ã‡§§‡•á ‡§π‡•Å‡§è ‡§≠‡•Ä, ‡§™‡§ï‡•ç‡§∑ ‡§á‡§∏ ‡§¨‡§æ‡§§ ‡§∏‡•á ‡§∏‡§π‡§Æ‡§§ ‡§π‡•à‡§Ç ‡§ï‡§ø ‡§ï‡•ã‡§à ‡§≠‡•Ä ‡§™‡§ï‡•ç‡§∑ ‡§¶‡•Ç‡§∏‡§∞‡•á ‡§™‡§ï‡•ç‡§∑ ‡§ï‡•á ‡§™‡•ç‡§∞‡§§‡§ø ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä ‡§Ö‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡§ï‡•ç‡§∑, ‡§µ‡§ø‡§∂‡•á‡§∑, ‡§Ø‡§æ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ‡•Ä ‡§ï‡•ç‡§∑‡§§‡§ø ‡§ï‡•á ‡§≤‡§ø‡§è ‡§â‡§§‡•ç‡§§‡§∞‡§¶‡§æ‡§Ø‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã‡§ó‡§æ‡•§ ‡§á‡§∏ ‡§∏‡§Æ‡§ù‡•å‡§§‡•á ‡§ï‡•Ä ‡§µ‡•à‡§ß‡§§‡§æ, ‡§µ‡•ç‡§Ø‡§æ‡§ñ‡•ç‡§Ø‡§æ, ‡§î‡§∞ ‡§™‡•ç‡§∞‡§¶‡§∞‡•ç‡§∂‡§® ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§Ö‡§ß‡§ø‡§ï‡§æ‡§∞ ‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§ï‡•á ‡§ï‡§æ‡§®‡•Ç‡§®‡•ã‡§Ç ‡§ï‡•á ‡§Ö‡§®‡•Å‡§∏‡§æ‡§∞ ‡§∂‡§æ‡§∏‡§ø‡§§ ‡§î‡§∞ ‡§∏‡§Æ‡§ù‡•á ‡§ú‡§æ‡§è‡§Ç‡§ó‡•á, ‡§á‡§∏‡§ï‡•á ‡§ï‡§æ‡§®‡•Ç‡§® ‡§∏‡§ø‡§¶‡•ç‡§ß‡§æ‡§Ç‡§§‡•ã‡§Ç ‡§ï‡•á ‡§ü‡§ï‡§∞‡§æ‡§µ ‡§ï‡•Ä ‡§™‡§∞‡§µ‡§æ‡§π ‡§ï‡§ø‡§è ‡§¨‡§ø‡§®‡§æ‡•§", letter: "‡§™‡•ç‡§∞‡§ø‡§Ø [‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§‡§ï‡§∞‡•ç‡§§‡§æ ‡§ï‡§æ ‡§®‡§æ‡§Æ],\n‡§Ü‡§∂‡§æ ‡§π‡•à ‡§ï‡§ø ‡§Ü‡§™ ‡§∏‡•ç‡§µ‡§∏‡•ç‡§• ‡§π‡•ã‡§Ç‡§ó‡•á‡•§ ‡§Æ‡•à‡§Ç ‡§Ü‡§ú ‡§Ü‡§™‡§∏‡•á ‡§Ü‡§ó‡§æ‡§Æ‡•Ä ‡§™‡§∞‡§ø‡§Ø‡•ã‡§ú‡§®‡§æ ‡§ï‡•Ä ‡§∏‡§Æ‡§Ø ‡§∏‡•Ä‡§Æ‡§æ ‡§™‡§∞ ‡§ö‡§∞‡•ç‡§ö‡§æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§≤‡§ø‡§ñ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç‡•§ ‡§π‡§Æ‡•á‡§Ç ‡§Ø‡§π ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§∏‡§≠‡•Ä ‡§°‡§ø‡§≤‡§ø‡§µ‡§∞‡•á‡§¨‡§≤‡•ç‡§∏ ‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•á ‡§Ö‡§Ç‡§§ ‡§§‡§ï ‡§ú‡§Æ‡§æ ‡§ï‡§∞ ‡§¶‡§ø‡§è ‡§ú‡§æ‡§è‡§Ç‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡•ã ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§∞‡•Ç‡§™ ‡§¶‡•á‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ö‡§™‡§®‡•Ä ‡§∏‡§Ç‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§ü‡•Ä‡§Æ‡•ã‡§Ç ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡§Æ‡§®‡•ç‡§µ‡§Ø ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§á‡§∏ ‡§Æ‡§æ‡§Æ‡§≤‡•á ‡§™‡§∞ ‡§Ü‡§™‡§ï‡•á ‡§§‡•ç‡§µ‡§∞‡§ø‡§§ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§ï‡•Ä ‡§Ö‡§§‡•ç‡§Ø‡§ß‡§ø‡§ï ‡§∏‡§∞‡§æ‡§π‡§®‡§æ ‡§ï‡•Ä ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à‡•§\n\n‡§∏‡§æ‡§≠‡§æ‡§∞,\n[‡§Ü‡§™‡§ï‡§æ ‡§®‡§æ‡§Æ]", punctuation: "‡§∞‡•Å‡§ï‡•ã, ‡§ï‡•ç‡§Ø‡§æ? ‡§â‡§∏‡§®‡•á ‡§™‡•Ç‡§õ‡§æ, \"‡§ï‡•ç‡§Ø‡§æ ‡§§‡•Å‡§Æ ‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§π‡•ã?\" ‡§Æ‡•Å‡§ù‡•á ‡§Ø‡§ï‡•Ä‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à... ‡§ö‡§≤‡•ã ‡§ó‡§æ‡§á‡§° (‡§™‡•á‡§ú 5) ‡§¶‡•á‡§ñ‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§π‡•à‡§Ç: ‡§≤‡§æ‡§≤, ‡§π‡§∞‡§æ, ‡§Ø‡§æ ‡§®‡•Ä‡§≤‡§æ; ‡§π‡§æ‡§≤‡§æ‡§Å‡§ï‡§ø, ‡§Æ‡•Å‡§ù‡•á ‡§™‡§π‡§≤‡§æ ‡§µ‡§æ‡§≤‡§æ ‡§™‡§∏‡§Ç‡§¶ ‡§π‡•à‡•§ ‡§Ø‡§π ‡§è‡§ï '‡§ú‡•Ä‡§§-‡§ú‡•Ä‡§§' ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§π‡•à, ‡§π‡•à ‡§®‡§æ?", capitalization: "‡§∏‡§Ç‡§Ø‡•Å‡§ï‡•ç‡§§ ‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞ (UN) ‡§ï‡§æ ‡§Æ‡•Å‡§ñ‡•ç‡§Ø‡§æ‡§≤‡§Ø ‡§®‡•ç‡§Ø‡•Ç‡§Ø‡•â‡§∞‡•ç‡§ï ‡§∂‡§π‡§∞ ‡§Æ‡•á‡§Ç ‡§π‡•à‡•§ ‡§°‡•â. ‡§∂‡§∞‡•ç‡§Æ‡§æ ‡§î‡§∞ ‡§â‡§®‡§ï‡•á ‡§∏‡§π‡§Ø‡•ã‡§ó‡•Ä, ‡§™‡•ç‡§∞‡•ã‡§´‡•á‡§∏‡§∞ ‡§µ‡§∞‡•ç‡§Æ‡§æ, ‡§™‡§ø‡§õ‡§≤‡•á ‡§∏‡•ã‡§Æ‡§µ‡§æ‡§∞ ‡§ï‡•ã ‡§™‡•á‡§∞‡§ø‡§∏, ‡§´‡•ç‡§∞‡§æ‡§Ç‡§∏ ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡•ç‡§Æ‡•á‡§≤‡§® ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•Å‡§è‡•§ ‡§â‡§®‡•ç‡§π‡•ã‡§Ç‡§®‡•á ‡§Ü‡§∞‡•ç‡§ï‡§ü‡§ø‡§ï ‡§∏‡§∞‡•ç‡§ï‡§≤ ‡§™‡§∞ ‡§ú‡§≤‡§µ‡§æ‡§Ø‡•Å ‡§™‡§∞‡§ø‡§µ‡§∞‡•ç‡§§‡§® ‡§ï‡•á ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ ‡§™‡§∞ ‡§ö‡§∞‡•ç‡§ö‡§æ ‡§ï‡•Ä‡•§", }
            };

            const getRandomFallback = (lang) => OFFLINE_FALLBACK[lang][Math.floor(Math.random() * OFFLINE_FALLBACK[lang].length)];
            const generateRandomText = (chars, wordLength, numWords) => { let text = ''; for (let i = 0; i < numWords; i++) { let word = ''; const currentWordLength = Math.floor(Math.random() * (wordLength - 2)) + 2; for (let j = 0; j < currentWordLength; j++) { word += chars[Math.floor(Math.random() * chars.length)]; } text += word + ' '; } return text.trim(); };
            const getTypingText = async (language = 'en') => {
                 const sources = [
                    async () => { const url = language === 'hi' ? 'https://api.rss2json.com/v1/api.json?rss_url=https://www.jagran.com/education/rssfeed.xml' : 'https://api.rss2json.com/v1/api.json?rss_url=https://www.thehindu.com/education/feeder/default.rss'; const res = await fetch(url, { cache: "no-cache" }); if (!res.ok) throw new Error("RSS Network error"); const data = await res.json(); if (data.status !== 'ok' || !data.items || data.items.length === 0) throw new Error("News source failed"); return data.items[Math.floor(Math.random() * data.items.length)].description.replace(/<[^>]+>/g, '').trim(); },
                    async () => { const url = language === 'hi' ? 'https://hi.wikipedia.org/api/rest_v1/page/random/summary' : 'https://en.wikipedia.org/api/rest_v1/page/random/summary'; const res = await fetch(url); if (!res.ok) throw new Error("Wikipedia Network error"); const data = await res.json(); if (!data.extract) throw new Error("Wikipedia extract failed"); return data.extract; }
                ];
                for (const source of sources) { try { const text = await Promise.race([ source(), new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 4000)) ]); if (text && text.length > 50) return text; } catch (err) { console.warn("A text source failed or timed out, trying next..."); } }
                console.warn("All online sources failed. Using offline fallback."); return getRandomFallback(language);
            };
            const appendMoreText = async () => {
                if (appState.session.isFetchingMoreText || !appState.isPracticeActive) return;
                appState.session.isFetchingMoreText = true; dom.loadingStatus.textContent = 'Generating more text...';
                try {
                    const newText = await appState.config.textGenerator();
                    if (newText && appState.isPracticeActive) {
                        const separator = ' '; appState.config.sourceText += separator + newText; const newChars = splitTextToChars(separator + newText); appState.config.sourceChars.push(...newChars); appState.config.sourceWords = appState.config.sourceText.split(/\s+/).filter(Boolean);
                        const newHtml = newChars.map(char => `<span class="char">${char}</span>`).join(''); dom.textDisplay.insertAdjacentHTML('beforeend', newHtml);
                    }
                } catch (error) { console.error("Failed to generate/fetch more text:", error); } finally { dom.loadingStatus.textContent = ''; appState.session.isFetchingMoreText = false; }
            };
            
            const HINDI_BEGINNER_PRACTICE = { "1. Home Row": "‡§ï‡§∞ ‡§π‡§Æ ‡§§‡§∞‡§∏; ‡§Æ‡§π‡§ï ‡§ï‡§∏‡§ï; ‡§ï‡§Æ‡§≤ ‡§Æ‡§π‡§≤; ‡§∏‡§ø‡§∞ ‡§ï‡§ø‡§∏; ‡§ï‡•á‡§∏‡§∞ ‡§ï‡•ã‡§Æ‡§≤; ‡§π‡§Æ‡•á‡§∂‡§æ ‡§∏‡§Æ‡§∞;", "2. Top Row": "‡§™‡§† ‡§õ‡§†; ‡§™‡•Ä‡§† ‡§Æ‡•Ä‡§†‡•Ä; ‡§™‡§æ‡§† ‡§™‡•Ä‡§†; ‡§ï‡•à‡§∏‡§æ ‡§¨‡•à‡§†‡§æ; ‡§´‡•å‡§ú‡•Ä ‡§ö‡•å‡§ï‡•Ä; ‡§Æ‡•Ä‡§†‡§æ ‡§™‡§æ‡§†;", "3. Bottom Row": "‡§ú‡§ó ‡§Æ‡§ó ‡§ó‡§ú; ‡§Ö‡§¨ ‡§ú‡§¨; ‡§ß‡§® ‡§¨‡•ù; ‡§ó‡•ú‡§¨‡•ú ‡§Ö‡§ú‡§Ø; ‡§Ö‡§ó‡§∞ ‡§°‡§ó‡§∞; ‡§≠‡§ú‡§® ‡§ó‡§ó‡§®;", "4. Home + Top": "‡§ü‡§ø‡§ï‡§ü ‡§Æ‡§ø‡§†‡§æ‡§à; ‡§ï‡§†‡•ã‡§∞ ‡§ï‡§†‡§ø‡§®; ‡§†‡•Ä‡§ï ‡§†‡§æ‡§ï; ‡§™‡§π‡§≤‡§æ ‡§™‡§π‡§∞; ‡§Æ‡§π‡§´‡§ø‡§≤ ‡§∂‡§æ‡§Æ‡§ø‡§≤;", "5. Home + Bottom": "‡§ú‡§ó‡§π ‡§Æ‡§π‡§≤; ‡§ó‡§∞‡§Æ ‡§ñ‡§¨‡§∞; ‡§∏‡§π‡§ú ‡§∏‡§Æ‡§ù; ‡§¨‡§æ‡§π‡§∞ ‡§≠‡§ú‡§®; ‡§Æ‡§¶‡§¶ ‡§Æ‡§ï‡§∏‡§¶;", "6. Top + Bottom": "‡§Ö‡§ü‡§ï ‡§≠‡§ü‡§ï; ‡§™‡•ù‡§®‡§æ ‡§ö‡•ù‡§®‡§æ; ‡§ó‡§†‡§® ‡§¨‡§ö‡§™‡§®; ‡§Ö‡§ú‡§Ø ‡§Ö‡§ö‡§≤;", "7. Word Formation": "‡§ï‡§ø‡§∏‡§æ‡§® ‡§ï‡§ø‡§§‡§æ‡§¨; ‡§¨‡§æ‡§∞‡§ø‡§∂ ‡§∂‡§æ‡§Æ‡§ø‡§≤; ‡§ü‡•ã‡§ï‡§∞‡•Ä ‡§ï‡§ü‡•ã‡§∞‡•Ä; ‡§™‡§π‡§ö‡§æ‡§® ‡§Æ‡•á‡§π‡§Æ‡§æ‡§®;", "9. Random Row Mix": "‡§≠‡§æ‡§∞‡§§ ‡§Æ‡§π‡§æ‡§®; ‡§¨‡§ö‡§™‡§® ‡§ï‡•Ä ‡§Ø‡§æ‡§¶; ‡§∏‡§Æ‡§Ø ‡§ï‡§æ ‡§Æ‡§π‡§§‡•ç‡§µ; ‡§∏‡•ú‡§ï ‡§™‡§∞ ‡§ó‡§ú‡§∞‡§æ‡§ú; ‡§ï‡§≤‡§Æ ‡§¶‡§µ‡§æ‡§§;" };
            const practiceLevels = {
                "Beginner": { "1. Home Row": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["1. Home Row"]) : generateRandomText(KEYS.en.home, 5, 20), "2. Top Row": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["2. Top Row"]) : generateRandomText(KEYS.en.top, 5, 20), "3. Bottom Row": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["3. Bottom Row"]) : generateRandomText(KEYS.en.bottom, 5, 20), "4. Home + Top": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["4. Home + Top"]) : generateRandomText(KEYS.en.home + KEYS.en.top, 6, 25), "5. Home + Bottom": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["5. Home + Bottom"]) : generateRandomText(KEYS.en.home + KEYS.en.bottom, 6, 25), "6. Top + Bottom": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["6. Top + Bottom"]) : generateRandomText(KEYS.en.top + KEYS.en.bottom, 6, 25), "7. Word Formation": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["7. Word Formation"]) : generateRandomText(KEYS.en.home + KEYS.en.top, 4, 30), "8. Small Sentences": () => Promise.resolve(getRandomFallback(appState.lang)), "9. Random Row Mix": () => appState.lang === 'hi' ? Promise.resolve(HINDI_BEGINNER_PRACTICE["9. Random Row Mix"]) : generateRandomText(KEYS.en.home + KEYS.en.top + KEYS.en.bottom, 6, 25), "10. Numeric Practice": () => generateRandomText(KEYS.en.numbers + ' ', 5, 20), },
                "Skill Building": { "1. Random Words": () => getTypingText(appState.lang), "2. Sentence Practice": () => getTypingText(appState.lang), "3. Paragraph Practice": () => getTypingText(appState.lang), "4. Punctuation Practice": () => Promise.resolve(STATIC_TEXTS[appState.lang].punctuation), "5. Capitalization": () => Promise.resolve(STATIC_TEXTS[appState.lang].capitalization), "6. Numeric Row Practice": () => generateRandomText(KEYS.en.numbers + ' 123 456 7890 ', 7, 20), "7. Symbol Typing": () => Promise.resolve(STATIC_TEXTS.en.symbols), "8. Dictation Mode": () => getTypingText(appState.lang), "9. Mixed Practice": () => getTypingText(appState.lang), "10. Repetition Drill": async () => { const s = await getTypingText(appState.lang); return (s + " ").repeat(2).trim(); }, },
                "Advanced": { "1. Editorial Articles": () => getTypingText(appState.lang), "2. Technical Text": () => getTypingText(appState.lang), "3. Application Format": () => Promise.resolve(STATIC_TEXTS[appState.lang].application), "4. Government Notice": () => getTypingText(appState.lang), "5. Table Data Typing": () => Promise.resolve("Name|Age|City|Country\nJohn|30|New York|USA\nAnna|25|Paris|France\nMike|42|Tokyo|Japan"), "6. Speech Text": () => getTypingText(appState.lang), "7. Legal Paragraphs": () => Promise.resolve(STATIC_TEXTS[appState.lang].legal), "8. Complex Sentences": () => getTypingText(appState.lang), "9. News Report Practice": () => getTypingText(appState.lang), "10. Error Correction": () => getTypingText(appState.lang), },
                "Expert": { "1. Long Paragraph": () => getTypingText(appState.lang), "2. Letter Writing": () => Promise.resolve(STATIC_TEXTS[appState.lang].letter), "3. Report Typing": () => getTypingText(appState.lang), "4. Press Release": () => getTypingText(appState.lang), "5. Data Table Typing": () => Promise.resolve("ID,Product,Price,Stock\n101,Laptop,1200,50\n102,Mouse,25,200\n103,Keyboard,75,150\n104,Monitor,300,80"), "6. Essay Typing": () => getTypingText(appState.lang), "7. Mixed Format": () => Promise.resolve(`${STATIC_TEXTS[appState.lang].letter} \n\n ${STATIC_TEXTS[appState.lang].legal}`), "8. Official Document": () => getTypingText(appState.lang), "9. English-Hindi Mix": () => Promise.resolve("This is an English sentence. ‡§Ø‡§π ‡§è‡§ï ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§µ‡§æ‡§ï‡•ç‡§Ø ‡§π‡•à‡•§ We need to type both. ‡§π‡§Æ‡•á‡§Ç ‡§¶‡•ã‡§®‡•ã‡§Ç ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§®‡•á ‡§π‡•ã‡§Ç‡§ó‡•á‡•§"), "10. Multiple Passages": () => getTypingText(appState.lang), },
                "Exam Type": { "1. SSC Exam Mode": () => getTypingText(appState.lang), "2. CPCT Mode": () => getTypingText(appState.lang), "3. RSMSSB Mode": () => getTypingText(appState.lang), "4. UP Police Clerk": () => getTypingText(appState.lang), "5. Bank Clerk Mode": () => getTypingText(appState.lang), "6. Railway Typing": () => getTypingText(appState.lang), "7. High Court Clerk": () => getTypingText(appState.lang), "8. Insurance Typing": () => getTypingText(appState.lang), "9. MP DEO Typing": () => getTypingText(appState.lang), "10. Custom Exam Sim": () => getTypingText(appState.lang), },
                "Free Hand": { "Free Practice": () => Promise.resolve(""), },
                "Uplode Your Text": { "Paste Your Text And Start Practice": () => Promise.resolve(dom.pasteTextArea.value) }
            };
            let appState = {};
            let speedChart, accuracyChart; // Chart instances
            const BACKUP_KEY = 'ExamYatriTypingPermanentBackup';
            const DURATION_KEYS = {
                TODAY: 'ExamYatriTodayPracticeTime',
                TOTAL: 'ExamYatriTotalPracticeTime',
                DATE: 'ExamYatriLastPracticeDate'
            };

            const getStoredResults = () => { try { return JSON.parse(localStorage.getItem(BACKUP_KEY)) || []; } catch (e) { return []; } };
            const saveResults = (results) => { localStorage.setItem(BACKUP_KEY, JSON.stringify(results)); };
            
            const formatDuration = (totalSeconds) => {
                if (totalSeconds < 60) return `${totalSeconds}s`;
                if (totalSeconds < 3600) {
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    return `${minutes}m ${seconds}s`;
                }
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                return `${hours}h ${minutes}m`;
            };

            const updatePracticeTime = (sessionSeconds) => {
                const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
                const lastPracticeDate = localStorage.getItem(DURATION_KEYS.DATE);
                
                let todaySeconds = parseInt(localStorage.getItem(DURATION_KEYS.TODAY) || '0', 10);
                let totalSeconds = parseInt(localStorage.getItem(DURATION_KEYS.TOTAL) || '0', 10);
                
                if (today !== lastPracticeDate) {
                    todaySeconds = 0; // Reset for new day
                }
                
                todaySeconds += sessionSeconds;
                totalSeconds += sessionSeconds;
                
                localStorage.setItem(DURATION_KEYS.TODAY, todaySeconds);
                localStorage.setItem(DURATION_KEYS.TOTAL, totalSeconds);
                localStorage.setItem(DURATION_KEYS.DATE, today);

                return { todaySeconds, totalSeconds };
            };


            const resetState = () => {
                appState = { lang: 'en', timerId: null, isPracticeActive: false, config: { level: '', method: '', duration: 0, minusMarking: { enabled: false, value: 1 }, sourceText: '', sourceWords: [], sourceChars: [], isDynamicText: false, textGenerator: null }, session: { startTime: 0, timeLeft: 0, typedText: '', charIndex: 0, correctChars: 0, errorCount: 0, keystrokes: 0, backspaceCount: 0, isFetchingMoreText: false }, };
            };
            const populateLevels = () => { dom.levelSelect.innerHTML = Object.keys(practiceLevels).map(level => `<option value="${level}">${level}</option>`).join(''); };
            const populateMethods = () => { const selectedLevel = dom.levelSelect.value; const methods = Object.keys(practiceLevels[selectedLevel]); dom.methodSelect.innerHTML = methods.map(method => `<option value="${method}">${method}</option>`).join(''); handleMethodChange(); };
            const handleMethodChange = () => {
                 const isFreeHand = dom.levelSelect.value === 'Free Hand'; const isPasteText = dom.levelSelect.value === 'Uplode Your Text'; dom.durationSelect.disabled = isFreeHand; dom.minusMarkingEnabled.disabled = isFreeHand; if (isFreeHand && dom.minusMarkingEnabled.checked) { dom.minusMarkingEnabled.click(); } dom.pasteTextContainer.style.display = isPasteText ? 'block' : 'none';
            };
            const switchView = (view) => { dom.setupView.classList.toggle('active', view === 'setup'); dom.practiceView.classList.toggle('active', view === 'practice'); };
            const startPractice = async () => {
                if (dom.levelSelect.value === 'Uplode Your Text' && dom.pasteTextArea.value.trim() === '') { alert("Please paste your text before starting."); return; }
                dom.startBtn.disabled = true; dom.loadingStatus.textContent = 'Fetching text...';
                try {
                    const level = dom.levelSelect.value; const method = dom.methodSelect.value; const textGenerator = practiceLevels[level][method];
                    appState.config = { level: level, method: method, duration: parseInt(dom.durationSelect.value, 10) * 60, minusMarking: { enabled: dom.minusMarkingEnabled.checked, value: parseInt(dom.minusMarkingValue.value, 10) }, isDynamicText: level !== 'Free Hand' && level !== 'Uplode Your Text', textGenerator: textGenerator, sourceText: await textGenerator(), };
                    if (!appState.config.sourceText && appState.config.level !== 'Free Hand') { appState.config.sourceText = getRandomFallback(appState.lang); }
                    if (appState.config.level === 'Free Hand') {
                        dom.textDisplay.style.display = 'none'; dom.caret.style.display = 'none'; dom.freeHandArea.style.display = 'block'; dom.freeHandArea.value = '';
                    } else {
                        dom.textDisplay.style.display = 'block'; dom.freeHandArea.style.display = 'none'; appState.config.sourceWords = appState.config.sourceText.split(/\s+/).filter(Boolean); appState.config.sourceChars = splitTextToChars(appState.config.sourceText); dom.textDisplay.innerHTML = appState.config.sourceChars.map(char => `<span class="char">${char}</span>`).join(''); dom.textDisplay.className = appState.lang === 'hi' ? 'hindi' : '';
                    }
                    resetSession(); switchView('practice'); appState.config.level === 'Free Hand' ? dom.freeHandArea.focus() : dom.hiddenInput.focus();
                } catch (error) { console.error("Failed to start practice:", error); dom.loadingStatus.textContent = 'Error fetching text. Please try again.'; } finally { dom.loadingStatus.textContent = ''; dom.startBtn.disabled = false; }
            };
            const resetSession = () => { if (appState.timerId) clearInterval(appState.timerId); appState.isPracticeActive = false; appState.timerId = null; appState.session = { startTime: 0, timeLeft: appState.config.duration, typedText: '', charIndex: 0, correctChars: 0, errorCount: 0, keystrokes: 0, backspaceCount: 0, isFetchingMoreText: false }; dom.hiddenInput.value = ''; dom.textDisplayWrapper.scrollTop = 0; updateStatsDisplay(); updateTextDisplay(); };
            const handleTyping = () => {
                if (appState.session.timeLeft <= 0 && appState.config.level !== 'Free Hand' && appState.config.duration > 0) return;
                if (!appState.isPracticeActive && appState.config.duration > 0) { appState.isPracticeActive = true; appState.session.startTime = Date.now(); startTimer(); }
                appState.session.typedText = appState.config.level === 'Free Hand' ? dom.freeHandArea.value : dom.hiddenInput.value; updateTextDisplay();
                const remainingChars = appState.config.sourceChars.length - appState.session.charIndex; if (appState.config.isDynamicText && remainingChars < 100) { appendMoreText(); }
                if (appState.config.level !== 'Free Hand' && appState.session.charIndex === appState.config.sourceChars.length && !appState.config.isDynamicText) { endPractice(); }
            };
            const startTimer = () => { if (appState.timerId || appState.config.duration <= 0) return; appState.timerId = setInterval(() => { if (appState.isPracticeActive) { const elapsed = Math.floor((Date.now() - appState.session.startTime) / 1000); appState.session.timeLeft = appState.config.duration - elapsed; updateStatsDisplay(); } if (appState.session.timeLeft <= 0) { endPractice(); } }, 250); };
            const updateTextDisplay = () => {
                if (appState.config.level === 'Free Hand') return;
                const typedChars = splitTextToChars(appState.session.typedText); const charElements = dom.textDisplay.querySelectorAll('.char'); appState.session.charIndex = typedChars.length; let correctCount = 0; let errorCount = 0;
                charElements.forEach((charEl, index) => { if (index < appState.session.charIndex) { if (typedChars[index] === appState.config.sourceChars[index]) { charEl.className = 'char correct'; correctCount++; } else { charEl.className = 'char incorrect'; errorCount++; } } else { charEl.className = 'char'; } });
                appState.session.correctChars = correctCount; appState.session.errorCount = errorCount; updateCaretPosition();
            };
            const updateCaretPosition = () => {
                const charElements = dom.textDisplay.querySelectorAll('.char'); const isAtEnd = appState.session.charIndex >= charElements.length; const currentEl = isAtEnd ? charElements[charElements.length - 1] : charElements[appState.session.charIndex];
                if (!currentEl) { dom.caret.style.display = 'none'; return; }
                dom.caret.style.display = 'block'; const currentElRect = currentEl.getBoundingClientRect(); dom.caret.style.left = `${currentEl.offsetLeft + (isAtEnd ? currentEl.offsetWidth : 0)}px`; dom.caret.style.top = `${currentEl.offsetTop}px`;
                const wrapper = dom.textDisplayWrapper; const caretTop = currentEl.offsetTop; const caretHeight = currentEl.offsetHeight;
                if (caretTop < wrapper.scrollTop) { wrapper.scrollTop = caretTop - caretHeight; } else if (caretTop + caretHeight > wrapper.scrollTop + wrapper.clientHeight) { wrapper.scrollTop = caretTop + caretHeight - wrapper.clientHeight; }
            };
            const updateStatsDisplay = () => {
                const duration = appState.config.duration > 0 ? Math.max(0, appState.session.timeLeft) : (appState.isPracticeActive ? Math.floor((Date.now() - appState.session.startTime) / 1000) : 0);
                const minutes = Math.floor(duration / 60); const seconds = duration % 60; dom.stats.time.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                if (!appState.isPracticeActive && appState.session.startTime === 0) return;
                const elapsedMinutes = (Date.now() - appState.session.startTime) / 60000; if(elapsedMinutes <= 0) return;
                const totalTypedChars = appState.session.typedText.length; const grossWpm = (totalTypedChars / 5) / elapsedMinutes; const errorCount = appState.session.errorCount; const correctChars = totalTypedChars - errorCount;
                const netWpm = elapsedMinutes > 0 ? (correctChars / 5) / elapsedMinutes : 0; const accuracy = totalTypedChars > 0 ? (correctChars / totalTypedChars) * 100 : 100;
                dom.stats.grossWpm.textContent = Math.round(grossWpm); dom.stats.netWpm.textContent = Math.round(Math.max(0, netWpm)); dom.stats.errors.textContent = errorCount; dom.stats.accuracy.textContent = `${Math.round(accuracy)}%`;
            };
            const endPractice = () => { if (!appState.isPracticeActive && appState.session.startTime > 0) return; if (appState.timerId) clearInterval(appState.timerId); appState.isPracticeActive = false; appState.session.timeLeft = 0; updateStatsDisplay(); dom.hiddenInput.blur(); dom.freeHandArea.blur(); showResults(); };
            
            const levenshtein = (a, b) => {
              if (a === b) return 0;
              const n = a.length, m = b.length;
              if (n === 0) return m;
              if (m === 0) return n;
              let prev = Array(m + 1).fill(0), cur = Array(m + 1).fill(0);
              for (let j = 0; j <= m; j++) prev[j] = j;
              for (let i = 1; i <= n; i++) {
                cur[0] = i;
                for (let j = 1; j <= m; j++) {
                  const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                  cur[j] = Math.min(prev[j] + 1, cur[j - 1] + 1, prev[j - 1] + cost);
                }
                [prev, cur] = [cur, prev];
              }
              return prev[m];
            }

            const computeTypingMetrics = ({ referenceText = "", typedText = "", timeSeconds = 1 }) => {
              // --- START OF CORRECTION ---
              // This function is corrected to prevent counting untyped words as mistakes
              // and to ensure that the total number of wrong words does not exceed the number of typed words.
              
              const warnings = [];
              if (timeSeconds <= 0) {
                warnings.push("Invalid timeSeconds; must be > 0. Using 1 second as fallback.");
                timeSeconds = 1;
              }
              const ref = referenceText.trim().replace(/\s+/g, " ");
              const typed = typedText.trim().replace(/\s+/g, " ");
              const refWords = ref.length ? ref.split(" ") : [];
              const typedWords = typed.length ? typed.split(" ") : [];
              const totalKeystrokes = typed.length;
              const wordsTypedCount = typedWords.length;

              let fullMistakes = 0, halfMistakes = 0;
              const perWord = [];

              // CHANGE 1: Iterate only up to the number of words the user actually typed.
              // This is the core fix. It prevents the loop from continuing through the rest of the
              // reference text and marking all untyped words as "omitted" mistakes.
              const comparisonLength = typedWords.length;

              for (let i = 0; i < comparisonLength; i++) {
                const typedWord = typedWords[i];
                const refWord = refWords[i] ?? null;

                if (refWord === null) {
                  // This handles cases where the user types more words than are in the reference text.
                  // These are considered "extra" words and are counted as full mistakes.
                  fullMistakes++;
                  perWord.push({ source: null, typed: typedWord, status: "extra" });
                  continue;
                }
                
                if (typedWord === refWord) {
                  // The typed word matches the reference word.
                  perWord.push({ source: refWord, typed: typedWord, status: "correct" });
                  continue;
                }
                
                // If we reach here, the words do not match, so it's a mistake.
                // We use Levenshtein distance to determine if it's a half or full mistake.
                // This logic remains the same as the original.
                const distance = levenshtein(refWord, typedWord);
                const threshold = Math.ceil(refWord.length / 2);
                
                if (distance > 0 && distance < threshold) {
                  halfMistakes++;
                  perWord.push({ source: refWord, typed: typedWord, status: "half" });
                } else {
                  fullMistakes++;
                  perWord.push({ source: refWord, typed: typedWord, status: "full" });
                }
              }

              // CHANGE 2: Handle the display of untyped (omitted) words for the results comparison UI.
              // After checking the typed words, we loop through the remainder of the reference text.
              // These words are marked as "omitted" for the visual comparison, but critically,
              // they are NOT counted as mistakes, fixing the main bug.
              if (refWords.length > typedWords.length) {
                  for (let i = typedWords.length; i < refWords.length; i++) {
                      perWord.push({ source: refWords[i], typed: null, status: "omitted" });
                  }
              }

              const totalWrongWords = fullMistakes + halfMistakes;
              
              // The logic below for calculating WPM and accuracy remains unchanged, as requested.
              // It now operates on the correctly calculated mistake counts.
              const errorPenaltyWords = fullMistakes + (halfMistakes / 2);
              const minutes = timeSeconds / 60;
              
              const grossWPM = minutes > 0 ? (totalKeystrokes / 5) / minutes : 0;
              const errorPenaltyRate = minutes > 0 ? errorPenaltyWords / minutes : 0;
              const netWPM = Math.max(0, grossWPM - errorPenaltyRate);
              const accuracy = grossWPM > 0 ? (netWPM / grossWPM) * 100 : 0;

              return {
                totalKeystrokes,
                wordsTypedCount,
                fullMistakes,
                halfMistakes,
                totalWrongWords,
                grossWPM: +grossWPM.toFixed(2),
                netWPM: +netWPM.toFixed(2),
                accuracyPercent: +accuracy.toFixed(2),
                wordAnalysis: perWord,
                warnings
              };
              // --- END OF CORRECTION ---
            }

            const showResults = () => {
                const timeTakenSec = appState.isPracticeActive ? 0 : (appState.session.startTime > 0 ? Math.round((Date.now() - appState.session.startTime) / 1000) : appState.config.duration);
                const durationMinutes = appState.config.duration / 60;
                
                const metrics = computeTypingMetrics({
                    referenceText: appState.config.sourceText,
                    typedText: appState.session.typedText,
                    timeSeconds: timeTakenSec > 0 ? timeTakenSec : appState.config.duration
                });
                
                const timeTakenMin = (timeTakenSec > 0 ? timeTakenSec : appState.config.duration) / 60;

                const isQualified = metrics.netWPM >= 30 && metrics.accuracyPercent >= 90;
                
                const minKeystrokes = 125 * timeTakenMin;
                const keystrokeWarning = metrics.totalKeystrokes < minKeystrokes && timeTakenMin > 0 ? `Key strokes typed (${metrics.totalKeystrokes}) are less than minimum required (${Math.round(minKeystrokes)}). Calculation may be affected.` : (metrics.warnings.length > 0 ? metrics.warnings.join(' ') : '');


                dom.newResults.passageTitle.textContent = `${appState.config.level}: ${appState.config.method}`;
                dom.newResults.timeDuration.textContent = `${durationMinutes.toFixed(2)}`;
                dom.newResults.timeTaken.textContent = `${timeTakenMin.toFixed(2)}`;
                dom.newResults.keystrokes.textContent = metrics.totalKeystrokes;
                dom.newResults.wordsTyped.textContent = metrics.wordsTypedCount;
                dom.newResults.fullMistakes.textContent = metrics.fullMistakes;
                dom.newResults.halfMistakes.textContent = metrics.halfMistakes;
                dom.newResults.totalWrongWords.textContent = metrics.totalWrongWords;
                dom.newResults.accuracy.textContent = metrics.accuracyPercent.toFixed(2);
                dom.newResults.grossSpeed.textContent = metrics.grossWPM.toFixed(2);
                dom.newResults.netSpeed.textContent = metrics.netWPM.toFixed(2);
                dom.newResults.backspaceCount.textContent = appState.session.backspaceCount;
                
                dom.newResults.resultText.textContent = isQualified ? "Qualified" : "Not Qualified";
                dom.newResults.resultCard.className = isQualified ? 'result-card qualified' : 'result-card not-qualified';
                dom.newResults.keystrokeWarning.textContent = keystrokeWarning;
                
                const errorPenaltyWords = metrics.fullMistakes + (metrics.halfMistakes / 2);
                const formulaParts = [
                    `<code>Error Penalty = Full (${metrics.fullMistakes}) + Half (${metrics.halfMistakes} √∑ 2) = ${errorPenaltyWords.toFixed(2)} words</code>`,
                    `<code>Gross WPM = (Total Chars Typed √∑ 5) √∑ Time = (${metrics.totalKeystrokes} √∑ 5) √∑ ${timeTakenMin.toFixed(2)} = ${metrics.grossWPM.toFixed(2)}</code>`,
                    `<code>Net WPM = Gross WPM - (Error Penalty √∑ Time) = ${metrics.grossWPM.toFixed(2)} - (${errorPenaltyWords.toFixed(2)} √∑ ${timeTakenMin.toFixed(2)}) = ${metrics.netWPM.toFixed(2)}</code>`,
                ];
                dom.newResults.formulaNote.innerHTML = formulaParts.join('\n');

                let originalHTML = '', typedHTML = '';
                metrics.wordAnalysis.forEach(({ source, typed, status }) => {
                    const s = source || '';
                    const t = typed || '';
                    switch(status) {
                        case 'correct': originalHTML += `<span class="correct-word">${s}</span> `; typedHTML += `<span class="correct-word">${t}</span> `; break;
                        case 'half': originalHTML += `<span class="half-mistake-word">${s}</span> `; typedHTML += `<span class="half-mistake-word">${t}</span> `; break;
                        case 'full': originalHTML += `<span class="wrong-word">${s}</span> `; typedHTML += `<span class="wrong-word">${t}</span> `; break;
                        case 'omitted': originalHTML += `<span class="omitted-word">${s}</span> `; typedHTML += ` `; break;
                        case 'extra': originalHTML += ` `; typedHTML += `<span class="wrong-word">${t}</span> `; break;
                    }
                });

                dom.newResults.originalPassage.innerHTML = originalHTML;
                dom.newResults.typedPassage.innerHTML = typedHTML;

                const currentResult = {
                    timestamp: Date.now(),
                    level: appState.config.level,
                    method: appState.config.method,
                    lang: appState.lang,
                    duration: durationMinutes,
                    grossWPM: metrics.grossWPM,
                    netWPM: metrics.netWPM,
                    accuracy: metrics.accuracyPercent,
                    errors: metrics.totalWrongWords,
                    keystrokes: metrics.totalKeystrokes,
                    backspaceCount: appState.session.backspaceCount,
                    qualified: isQualified,
                    wordAnalysis: metrics.wordAnalysis,
                };

                const allResults = getStoredResults();
                allResults.push(currentResult);
                saveResults(allResults);

                const { todaySeconds, totalSeconds } = updatePracticeTime(timeTakenSec);
                dom.practiceDurationSummary.style.display = 'block';
                dom.resTodayPracticeTime.textContent = formatDuration(todaySeconds);
                dom.resTotalPracticeTime.textContent = formatDuration(totalSeconds);

                renderAnalytics(allResults);

                dom.resultsModal.classList.add('active');
            };

            const hideResults = () => {
                dom.resultsModal.classList.remove('active');
                if (speedChart) speedChart.destroy();
                if (accuracyChart) accuracyChart.destroy();
                dom.practiceDurationSummary.style.display = 'none';
                dom.performanceReviewSection.style.display = 'none';
                dom.weaknessAnalysisSection.style.display = 'none';
                dom.improvementTipsSection.style.display = 'none';
                dom.progressGraphsSection.style.display = 'none';
            };

            const renderAnalytics = (results) => {
                const currentResult = results[results.length - 1];
                renderPerformanceReview(results);
                renderWeaknessAnalysis(results);
                renderProgressGraphs(results);
                renderImprovementTips(currentResult);
            };

            const renderPerformanceReview = (results) => {
                if (results.length < 2) {
                    dom.performanceReviewSection.style.display = 'none';
                    return;
                }
                dom.performanceReviewSection.style.display = 'block';
                const current = results[results.length - 1];
                const previous = results[results.length - 2];
                
                let feedback = [];
                const wpmDiff = current.netWPM - previous.netWPM;
                const accDiff = current.accuracy - previous.accuracy;
                const errDiff = current.errors - previous.errors;

                if (wpmDiff > 0) feedback.push(`Speed improved by <span style="color:var(--primary-color)">+${wpmDiff.toFixed(2)} WPM</span>.`);
                else if (wpmDiff < 0) feedback.push(`Speed decreased by <span style="color:var(--error-color)">${wpmDiff.toFixed(2)} WPM</span>.`);
                
                if (accDiff > 0) feedback.push(`Accuracy increased by <span style="color:var(--primary-color)">+${accDiff.toFixed(2)}%</span>.`);
                else if (accDiff < 0) feedback.push(`Accuracy decreased by <span style="color:var(--error-color)">${accDiff.toFixed(2)}%</span>.`);

                if (errDiff < 0) feedback.push(`Errors reduced by <span style="color:var(--primary-color)">${-errDiff}</span>.`);
                else if (errDiff > 0) feedback.push(`Errors increased by <span style="color:var(--error-color)">${errDiff}</span>.`);

                if (feedback.length === 0) feedback.push("Your performance is consistent. Keep practicing!");
                else if (wpmDiff > 0 && accDiff > 0) feedback.push("Excellent improvement! Keep up the great work!");
                else if (wpmDiff < 0 || accDiff < 0) feedback.push("Focus on consistency and accuracy in your next session.");
                
                dom.performanceFeedback.innerHTML = feedback.join('\n');
            };

            const renderWeaknessAnalysis = (results) => {
                const mistakeMap = new Map();
                results.flatMap(r => r.wordAnalysis || [])
                    .filter(w => w.status !== 'correct' && w.source)
                    .forEach(w => {
                        if (!mistakeMap.has(w.source)) {
                            mistakeMap.set(w.source, { count: 0, typedAs: new Map() });
                        }
                        const entry = mistakeMap.get(w.source);
                        entry.count++;
                        if (w.typed) {
                            entry.typedAs.set(w.typed, (entry.typedAs.get(w.typed) || 0) + 1);
                        }
                    });

                if (mistakeMap.size === 0) {
                    dom.weaknessAnalysisSection.style.display = 'none';
                    return;
                }
                dom.weaknessAnalysisSection.style.display = 'block';
                const sortedMistakes = [...mistakeMap.entries()].sort((a, b) => b[1].count - a[1].count).slice(0, 5);
                
                let html = '<ul>';
                sortedMistakes.forEach(([source, data]) => {
                    const commonTyped = [...data.typedAs.entries()].sort((a, b) => b[1] - a[1])[0];
                    html += `<li>You often mistype '<span class="mistake-word">${source}</span>' (${data.count} times)`;
                    if (commonTyped) {
                         html += `, e.g., as '<span class="suggestion-word">${commonTyped[0]}</span>'`;
                    }
                    html += `.</li>`;
                });
                html += '</ul>';
                dom.mistakesAnalysis.innerHTML = html;
            };

            const renderImprovementTips = (currentResult) => {
                const { accuracy, netWPM, grossWPM, backspaceCount, wordAnalysis } = currentResult;
                let tips = [];

                if (accuracy < 90) {
                    tips.push("Your accuracy is low. Try to focus on typing correctly rather than speed. Precision is key!");
                } else if (accuracy < 95) {
                    tips.push("Good accuracy! Slow down just a bit to eliminate those few remaining errors.");
                }

                const wpmDifference = grossWPM - netWPM;
                if (wpmDifference > 10) {
                    tips.push("A high number of errors is reducing your Net Speed. Focus on accuracy to see a big improvement.");
                }

                if (backspaceCount > (currentResult.keystrokes / 20)) { // If backspace is more than 5% of keystrokes
                    tips.push("You're using the backspace key frequently. Try to type more deliberately to build a better rhythm and flow.");
                }
                
                const halfMistakes = (wordAnalysis || []).filter(w => w.status === 'half').length;
                const fullMistakes = (wordAnalysis || []).filter(w => w.status === 'full').length;
                if (halfMistakes > fullMistakes && halfMistakes > 3) {
                     tips.push("You're making many minor typos (half mistakes). Double-check for small errors like an extra or missed letter before moving on.");
                }

                if (tips.length === 0) {
                    tips.push("Great work! Your performance is solid. Keep practicing regularly to maintain and improve your skills.");
                }
                
                dom.improvementTips.innerHTML = '<ul>' + tips.map(tip => `<li>${tip}</li>`).join('') + '</ul>';
                dom.improvementTipsSection.style.display = 'block';
            };


            const renderProgressGraphs = (results) => {
                if (results.length < 2) {
                    dom.progressGraphsSection.style.display = 'none';
                    return;
                }
                dom.progressGraphsSection.style.display = 'block';

                if (speedChart) speedChart.destroy();
                if (accuracyChart) accuracyChart.destroy();

                const labels = results.map((_, i) => `Test ${i + 1}`);
                const speedData = {
                    labels,
                    datasets: [
                        { label: 'Gross WPM', data: results.map(r => r.grossWPM), borderColor: '#2196F3', tension: 0.1, backgroundColor: 'rgba(33, 150, 243, 0.1)', fill: true },
                        { label: 'Net WPM', data: results.map(r => r.netWPM), borderColor: 'var(--primary-color)', tension: 0.1, backgroundColor: 'rgba(76, 175, 80, 0.1)', fill: true }
                    ]
                };
                const accuracyData = {
                    labels,
                    datasets: [
                        { label: 'Accuracy (%)', data: results.map(r => r.accuracy), borderColor: '#FFC107', tension: 0.1, yAxisID: 'y', backgroundColor: 'rgba(255, 193, 7, 0.1)', fill: true },
                        { label: 'Errors', data: results.map(r => r.errors), borderColor: 'var(--error-color)', tension: 0.1, yAxisID: 'y1', backgroundColor: 'rgba(244, 67, 54, 0.1)', fill: true }
                    ]
                };
                
                const chartOptions = {
                    responsive: true, maintainAspectRatio: true,
                    plugins: { legend: { labels: { color: '#ccc' } } },
                    scales: {
                        y: { beginAtZero: true, grid: { color: '#444' }, ticks: { color: '#ccc' } },
                        x: { grid: { color: '#444' }, ticks: { color: '#ccc', maxRotation: 0, autoSkip: true, maxTicksLimit: 10 } }
                    }
                };

                speedChart = new Chart(dom.speedChartCanvas, { type: 'line', data: speedData, options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Typing Speed (WPM)', color: '#fff' } } } });
                accuracyChart = new Chart(dom.accuracyChartCanvas, { type: 'line', data: accuracyData, options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Accuracy & Errors', color: '#fff' } }, scales: { ...chartOptions.scales, y1: { type: 'linear', display: true, position: 'right', beginAtZero: true, grid: { drawOnChartArea: false }, ticks: { color: '#ccc' } } } } });
            };

            const init = () => {
                resetState(); populateLevels(); populateMethods();
                Chart.defaults.color = '#ccc'; Chart.defaults.borderColor = '#444';
                const visitCountEl = document.getElementById("visitCount"); if (visitCountEl) { let count = parseInt(localStorage.getItem("visitorCount") || "0"); count++; localStorage.setItem("visitorCount", String(count)); visitCountEl.textContent = count.toLocaleString(); }
                dom.levelSelect.addEventListener('change', populateMethods);
                dom.methodSelect.addEventListener('change', handleMethodChange);
                dom.minusMarkingEnabled.addEventListener('change', (e) => { dom.minusMarkingValue.disabled = !e.target.checked; });
                [dom.langEnglishBtn, dom.langHindiBtn].forEach(btn => { btn.addEventListener('click', () => { dom.langEnglishBtn.classList.remove('active'); dom.langHindiBtn.classList.remove('active'); btn.classList.add('active'); appState.lang = btn.dataset.lang; }); });
                dom.startBtn.addEventListener('click', startPractice);
                dom.submitBtn.addEventListener('click', endPractice);
                dom.hiddenInput.addEventListener('input', handleTyping);
                dom.hiddenInput.addEventListener('keydown', (e) => { appState.session.keystrokes++; if (e.key === 'Backspace') { appState.session.backspaceCount++; } if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key)) e.preventDefault(); });
                dom.freeHandArea.addEventListener('input', handleTyping);
                dom.freeHandArea.addEventListener('keydown', (e) => { appState.session.keystrokes++; if (e.key === 'Backspace') { appState.session.backspaceCount++; } });
                dom.textDisplayWrapper.addEventListener('click', () => { appState.config.level === 'Free Hand' ? dom.freeHandArea.focus() : dom.hiddenInput.focus(); });
                
                dom.resultActions.retry.addEventListener('click', () => {
                    hideResults();
                    const oldConfig = { ...appState.config }; resetSession(); appState.config = oldConfig;
                    if(appState.config.level !== 'Free Hand') {
                        dom.textDisplay.innerHTML = appState.config.sourceChars.map(char => `<span class="char">${char}</span>`).join('');
                        dom.textDisplay.className = appState.lang === 'hi' ? 'hindi' : '';
                    }
                     dom.freeHandArea.value = '';
                    switchView('practice');
                    appState.config.level === 'Free Hand' ? dom.freeHandArea.focus() : dom.hiddenInput.focus();
                });
                dom.resultActions.newTest.addEventListener('click', () => {
                    if (appState.config.level === 'Uplode Your Text') dom.pasteTextArea.value = '';
                    hideResults();
                    startPractice();
                });
                dom.resultActions.backToHome.addEventListener('click', () => {
                    if (appState.config.level === 'Uplode Your Text') dom.pasteTextArea.value = '';
                    hideResults();
                    switchView('setup');
                });
                
                // Rules modal listeners
                dom.learnMoreBtn.addEventListener('click', () => {
                    dom.rulesModal.classList.add('active');
                });
                dom.closeRulesBtn.addEventListener('click', () => {
                    dom.rulesModal.classList.remove('active');
                });
                dom.rulesModal.addEventListener('click', (e) => {
                    if (e.target === dom.rulesModal) { // Click on backdrop
                        dom.rulesModal.classList.remove('active');
                    }
                });
            };

            init();
        });
    </script>
</body>
</html>
